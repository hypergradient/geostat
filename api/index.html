
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../examples/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.39">
    
    
      
        <title>API Reference - Geostat Documentation</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../style.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#api-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Geostat Documentation" class="md-header__button md-logo" aria-label="Geostat Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Geostat Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API Reference
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Geostat Documentation" class="md-nav__button md-logo" aria-label="Geostat Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Geostat Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    API Reference
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    API Reference
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.Featurizer" class="md-nav__link">
    <span class="md-ellipsis">
      Featurizer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.NormalizingFeaturizer" class="md-nav__link">
    <span class="md-ellipsis">
      NormalizingFeaturizer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.GP" class="md-nav__link">
    <span class="md-ellipsis">
      GP
    </span>
  </a>
  
    <nav class="md-nav" aria-label="GP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.GP--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.GP--details" class="md-nav__link">
    <span class="md-ellipsis">
      Details
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.GP--examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.Mix" class="md-nav__link">
    <span class="md-ellipsis">
      Mix
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.Model" class="md-nav__link">
    <span class="md-ellipsis">
      Model
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Model">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model--details" class="md-nav__link">
    <span class="md-ellipsis">
      Details
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model--examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model.fit" class="md-nav__link">
    <span class="md-ellipsis">
      fit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model.generate" class="md-nav__link">
    <span class="md-ellipsis">
      generate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model.predict" class="md-nav__link">
    <span class="md-ellipsis">
      predict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model.set" class="md-nav__link">
    <span class="md-ellipsis">
      set
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.kernel" class="md-nav__link">
    <span class="md-ellipsis">
      kernel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="kernel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Constant" class="md-nav__link">
    <span class="md-ellipsis">
      Constant
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Delta" class="md-nav__link">
    <span class="md-ellipsis">
      Delta
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.GammaExponential" class="md-nav__link">
    <span class="md-ellipsis">
      GammaExponential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.IntExponential" class="md-nav__link">
    <span class="md-ellipsis">
      IntExponential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.IntSquaredExponential" class="md-nav__link">
    <span class="md-ellipsis">
      IntSquaredExponential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Kernel" class="md-nav__link">
    <span class="md-ellipsis">
      Kernel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Mix" class="md-nav__link">
    <span class="md-ellipsis">
      Mix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Noise" class="md-nav__link">
    <span class="md-ellipsis">
      Noise
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Product" class="md-nav__link">
    <span class="md-ellipsis">
      Product
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.QuadStack" class="md-nav__link">
    <span class="md-ellipsis">
      QuadStack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Ramp" class="md-nav__link">
    <span class="md-ellipsis">
      Ramp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.RampStack" class="md-nav__link">
    <span class="md-ellipsis">
      RampStack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.SmoothConvex" class="md-nav__link">
    <span class="md-ellipsis">
      SmoothConvex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.SquaredExponential" class="md-nav__link">
    <span class="md-ellipsis">
      SquaredExponential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Stack" class="md-nav__link">
    <span class="md-ellipsis">
      Stack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.TrendPrior" class="md-nav__link">
    <span class="md-ellipsis">
      TrendPrior
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Wiener" class="md-nav__link">
    <span class="md-ellipsis">
      Wiener
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Examples
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    About
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.Featurizer" class="md-nav__link">
    <span class="md-ellipsis">
      Featurizer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.NormalizingFeaturizer" class="md-nav__link">
    <span class="md-ellipsis">
      NormalizingFeaturizer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.GP" class="md-nav__link">
    <span class="md-ellipsis">
      GP
    </span>
  </a>
  
    <nav class="md-nav" aria-label="GP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.GP--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.GP--details" class="md-nav__link">
    <span class="md-ellipsis">
      Details
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.GP--examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.Mix" class="md-nav__link">
    <span class="md-ellipsis">
      Mix
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.model.Model" class="md-nav__link">
    <span class="md-ellipsis">
      Model
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Model">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model--details" class="md-nav__link">
    <span class="md-ellipsis">
      Details
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model--examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model.fit" class="md-nav__link">
    <span class="md-ellipsis">
      fit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model.generate" class="md-nav__link">
    <span class="md-ellipsis">
      generate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model.predict" class="md-nav__link">
    <span class="md-ellipsis">
      predict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.model.Model.set" class="md-nav__link">
    <span class="md-ellipsis">
      set
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.geostat.kernel" class="md-nav__link">
    <span class="md-ellipsis">
      kernel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="kernel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Constant" class="md-nav__link">
    <span class="md-ellipsis">
      Constant
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Delta" class="md-nav__link">
    <span class="md-ellipsis">
      Delta
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.GammaExponential" class="md-nav__link">
    <span class="md-ellipsis">
      GammaExponential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.IntExponential" class="md-nav__link">
    <span class="md-ellipsis">
      IntExponential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.IntSquaredExponential" class="md-nav__link">
    <span class="md-ellipsis">
      IntSquaredExponential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Kernel" class="md-nav__link">
    <span class="md-ellipsis">
      Kernel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Mix" class="md-nav__link">
    <span class="md-ellipsis">
      Mix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Noise" class="md-nav__link">
    <span class="md-ellipsis">
      Noise
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Product" class="md-nav__link">
    <span class="md-ellipsis">
      Product
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.QuadStack" class="md-nav__link">
    <span class="md-ellipsis">
      QuadStack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Ramp" class="md-nav__link">
    <span class="md-ellipsis">
      Ramp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.RampStack" class="md-nav__link">
    <span class="md-ellipsis">
      RampStack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.SmoothConvex" class="md-nav__link">
    <span class="md-ellipsis">
      SmoothConvex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.SquaredExponential" class="md-nav__link">
    <span class="md-ellipsis">
      SquaredExponential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Stack" class="md-nav__link">
    <span class="md-ellipsis">
      Stack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.TrendPrior" class="md-nav__link">
    <span class="md-ellipsis">
      TrendPrior
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.geostat.kernel.Wiener" class="md-nav__link">
    <span class="md-ellipsis">
      Wiener
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="api-reference">API Reference</h1>
<!-- ::: src.geostat.custom_op
    options:
        show_root_heading: True
        show_source: True

--- -->



<div class="doc doc-object doc-class">



<h2 id="src.geostat.model.Featurizer" class="doc doc-heading">
            <code>src.geostat.model.Featurizer</code>


</h2>


    <div class="doc doc-contents first">


        <p>Featurizer class for producing feature matrices (F matrix) from location data.</p>
<p>The <code>Featurizer</code> applies a specified featurization function to the input location data 
and generates the corresponding feature matrix. If no featurization function is provided, 
it produces a matrix with appropriate dimensions containing only ones.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>featurization</code></td>
            <td>
                  <code><span title="typing.Callable">Callable</span> or None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A function that takes in the individual components of location data and returns the features.
If set to <code>None</code>, the featurizer will produce an empty feature matrix (i.e., only ones).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating a <code>Featurizer</code> using a custom featurization function:</p>
<pre><code>import tensorflow as tf
from geostat.model import Featurizer

# Define a custom featurization function
def simple_featurizer(x, y):
    return x, y, x * y

# Initialize the Featurizer
featurizer = Featurizer(simple_featurizer)
</code></pre>
<p>Using the <code>Featurizer</code> to transform location data:</p>
<pre><code>locs = tf.constant([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])
F_matrix = featurizer(locs)
print(F_matrix) # F_matrix will contain the features: (x, y, x*y) for each location
# tf.Tensor(
# [[ 1.  2.  2.]
#  [ 3.  4. 12.]
#  [ 5.  6. 30.]], shape=(3, 3), dtype=float32)
</code></pre>
<p>Handling the case where no featurization is provided:</p>
<pre><code>featurizer_no_feat = Featurizer(None)
F_matrix = featurizer_no_feat(locs)
print(F_matrix) # Since no featurization function is provided, F_matrix will have shape (3, 0)
# tf.Tensor([], shape=(3, 0), dtype=float32)
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>__call__</code> method is used to apply the featurization to input location data.</li>
<li>If <code>featurization</code> returns a tuple, it is assumed to represent multiple features, 
which will be stacked to form the feature matrix.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/model.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Featurizer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Featurizer class for producing feature matrices (F matrix) from location data.</span>

<span class="sd">    The `Featurizer` applies a specified featurization function to the input location data </span>
<span class="sd">    and generates the corresponding feature matrix. If no featurization function is provided, </span>
<span class="sd">    it produces a matrix with appropriate dimensions containing only ones.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        featurization (Callable or None):</span>
<span class="sd">            A function that takes in the individual components of location data and returns the features.</span>
<span class="sd">            If set to `None`, the featurizer will produce an empty feature matrix (i.e., only ones).</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating a `Featurizer` using a custom featurization function:</span>

<span class="sd">        ```</span>
<span class="sd">        import tensorflow as tf</span>
<span class="sd">        from geostat.model import Featurizer</span>

<span class="sd">        # Define a custom featurization function</span>
<span class="sd">        def simple_featurizer(x, y):</span>
<span class="sd">            return x, y, x * y</span>

<span class="sd">        # Initialize the Featurizer</span>
<span class="sd">        featurizer = Featurizer(simple_featurizer)</span>
<span class="sd">        ```</span>

<span class="sd">        Using the `Featurizer` to transform location data:</span>

<span class="sd">        ```</span>
<span class="sd">        locs = tf.constant([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])</span>
<span class="sd">        F_matrix = featurizer(locs)</span>
<span class="sd">        print(F_matrix) # F_matrix will contain the features: (x, y, x*y) for each location</span>
<span class="sd">        # tf.Tensor(</span>
<span class="sd">        # [[ 1.  2.  2.]</span>
<span class="sd">        #  [ 3.  4. 12.]</span>
<span class="sd">        #  [ 5.  6. 30.]], shape=(3, 3), dtype=float32)</span>
<span class="sd">        ```</span>

<span class="sd">        Handling the case where no featurization is provided:</span>

<span class="sd">        ```</span>
<span class="sd">        featurizer_no_feat = Featurizer(None)</span>
<span class="sd">        F_matrix = featurizer_no_feat(locs)</span>
<span class="sd">        print(F_matrix) # Since no featurization function is provided, F_matrix will have shape (3, 0)</span>
<span class="sd">        # tf.Tensor([], shape=(3, 0), dtype=float32)</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `__call__` method is used to apply the featurization to input location data.</span>
<span class="sd">        - If `featurization` returns a tuple, it is assumed to represent multiple features, </span>
<span class="sd">        which will be stacked to form the feature matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">featurization</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">featurization</span> <span class="o">=</span> <span class="n">featurization</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">):</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">featurization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># No features.</span>
            <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">locs</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">featurization</span><span class="p">(</span><span class="o">*</span><span class="n">tf</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feats</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span> <span class="c1"># One or many features.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">locs</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">featurization</span><span class="p">(</span><span class="o">*</span><span class="n">tf</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">feats</span> <span class="o">=</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">locs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feats</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">feats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># One feature.</span>
            <span class="k">return</span> <span class="n">e</span><span class="p">(</span><span class="n">feats</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div><hr />


<div class="doc doc-object doc-class">



<h2 id="src.geostat.model.NormalizingFeaturizer" class="doc doc-heading">
            <code>src.geostat.model.NormalizingFeaturizer</code>


</h2>


    <div class="doc doc-contents first">


        <p>NormalizingFeaturizer class for producing normalized feature matrices (F matrix) with an intercept.</p>
<p>The <code>NormalizingFeaturizer</code> takes raw location data and applies a specified featurization function.
It normalizes the resulting features and remembers normalization parameters using the mean and standard deviation calculated from the 
original data and adds an intercept feature (a column of ones) to the matrix.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>featurization</code></td>
            <td>
                  <code><span title="typing.Callable">Callable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A function or callable that defines how the input location data should be featurized.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>locs</code></td>
            <td>
                  <code>array - like or Tensor</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input location data used for calculating normalization parameters (mean and standard 
deviation) and featurizing new data.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating a <code>NormalizingFeaturizer</code> using a custom featurization function and location data:</p>
<pre><code>import tensorflow as tf
from geostat.model import NormalizingFeaturizer

# Define a simple featurization function
def custom_featurizer(x, y):
    return x, y, x * y

# Sample location data
locs = tf.constant([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])

# Create the NormalizingFeaturizer
norm_featurizer = NormalizingFeaturizer(custom_featurizer, locs)
</code></pre>
<p>Using the <code>NormalizingFeaturizer</code> to featurize new location data:</p>
<pre><code>new_locs = tf.constant([[7.0, 8.0], [9.0, 10.0]])
F_matrix = norm_featurizer(new_locs)
print(F_matrix) # F_matrix will contain normalized features with an additional intercept column
# tf.Tensor(
# [[1.        2.4494898 2.4494898 3.5676992]
#  [1.        3.6742349 3.6742349 6.50242  ]], shape=(2, 4), dtype=float32)
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The normalization parameters (<code>unnorm_mean</code> and <code>unnorm_std</code>) are calculated based on the 
initial <code>locs</code> data provided during initialization.</li>
<li>The <code>__call__</code> method applies the normalization and adds an intercept feature when used 
to featurize new location data.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/model.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">NormalizingFeaturizer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NormalizingFeaturizer class for producing normalized feature matrices (F matrix) with an intercept.</span>

<span class="sd">    The `NormalizingFeaturizer` takes raw location data and applies a specified featurization function.</span>
<span class="sd">    It normalizes the resulting features and remembers normalization parameters using the mean and standard deviation calculated from the </span>
<span class="sd">    original data and adds an intercept feature (a column of ones) to the matrix.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        featurization (Callable):</span>
<span class="sd">            A function or callable that defines how the input location data should be featurized.</span>
<span class="sd">        locs (array-like or Tensor):</span>
<span class="sd">            The input location data used for calculating normalization parameters (mean and standard </span>
<span class="sd">            deviation) and featurizing new data.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating a `NormalizingFeaturizer` using a custom featurization function and location data:</span>

<span class="sd">        ```</span>
<span class="sd">        import tensorflow as tf</span>
<span class="sd">        from geostat.model import NormalizingFeaturizer</span>

<span class="sd">        # Define a simple featurization function</span>
<span class="sd">        def custom_featurizer(x, y):</span>
<span class="sd">            return x, y, x * y</span>

<span class="sd">        # Sample location data</span>
<span class="sd">        locs = tf.constant([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])</span>

<span class="sd">        # Create the NormalizingFeaturizer</span>
<span class="sd">        norm_featurizer = NormalizingFeaturizer(custom_featurizer, locs)</span>
<span class="sd">        ```</span>

<span class="sd">        Using the `NormalizingFeaturizer` to featurize new location data:</span>

<span class="sd">        ```</span>
<span class="sd">        new_locs = tf.constant([[7.0, 8.0], [9.0, 10.0]])</span>
<span class="sd">        F_matrix = norm_featurizer(new_locs)</span>
<span class="sd">        print(F_matrix) # F_matrix will contain normalized features with an additional intercept column</span>
<span class="sd">        # tf.Tensor(</span>
<span class="sd">        # [[1.        2.4494898 2.4494898 3.5676992]</span>
<span class="sd">        #  [1.        3.6742349 3.6742349 6.50242  ]], shape=(2, 4), dtype=float32)</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The normalization parameters (`unnorm_mean` and `unnorm_std`) are calculated based on the </span>
<span class="sd">        initial `locs` data provided during initialization.</span>
<span class="sd">        - The `__call__` method applies the normalization and adds an intercept feature when used </span>
<span class="sd">        to featurize new location data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">featurization</span><span class="p">,</span> <span class="n">locs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unnorm_featurizer</span> <span class="o">=</span> <span class="n">Featurizer</span><span class="p">(</span><span class="n">featurization</span><span class="p">)</span>
        <span class="n">F_unnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unnorm_featurizer</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unnorm_mean</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">F_unnorm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unnorm_std</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">reduce_std</span><span class="p">(</span><span class="n">F_unnorm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">):</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">locs</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">F_unnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unnorm_featurizer</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>
        <span class="n">F_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">F_unnorm</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">unnorm_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">unnorm_std</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ones</span><span class="p">,</span> <span class="n">F_norm</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div><hr />


<div class="doc doc-object doc-class">



<h2 id="src.geostat.model.GP" class="doc doc-heading">
            <code>src.geostat.model.GP</code>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents first">


        <p>Gaussian Process (GP) model class with a mean function and a kernel.</p>
<p>This class represents a Gaussian Process with specified mean
and kernel functions.  If no mean is provided, a zero mean is
used by default. The kernel must always be specified.  The class
supports addition to combine two GP models, and it allows
gathering variables from the mean and kernel.</p>
<h4 id="src.geostat.model.GP--parameters">Parameters</h4>
<pre><code>mean (mean.Mean, optional):
    The mean function of the Gaussian Process. If not provided or set to 0, 
    a ZeroTrend is used as the default mean.

kernel (kernel.Kernel):
    The kernel function of the Gaussian Process. This parameter is required.
</code></pre>
<h4 id="src.geostat.model.GP--details">Details</h4>
<p>This is how to specify a GP with a squared exponential kernel
and superimposed uncorrelated noise:</p>
<pre><code class="language-python">import geostat.kernel as krn
from geostat import GP, Model, Parameters

p = Parameters(range=1., sill=1., nugget=1.)
kernel = krn.SquaredExponential(range=p.range, sill=p.sill) + krn.Noise(nugget=p.nugget)
gp = GP(0, kernel)
</code></pre>
<p>To use the GP, it must be wrapped in a model:</p>
<pre><code>model = Model(GP)
</code></pre>
<p>This model object can then be used to generate synthetic data,
fit its parameters to provided data, or make predictions, see
<a href="#src.geostat.model.GP--src.geostat.model.Model"><code>Model</code></a>.</p>
<p>In Geostat, GPs can be defined on locations in Euclidean space
of any dimension <span class="arithmatex">\(\mathbb{R}^D\)</span>, with the number of dimensions
specified implicitly by the shape of the location matrix given
to <code>fit()</code> or <code>generate()</code> in the <code>locs</code> argument.</p>
<p>GPs can also be defined on locations in <span class="arithmatex">\(\mathbb{R}^D \times
\mathbb{Z}\)</span> using the <a href="#src.geostat.model.GP--src.geostat.model.Mix"><code>Mix</code></a> operator.
This construction is for modeling multiple spatial quantities,
with each quantity occupying a different 'plane' of the space.
When multiple spatial quantities are involved, these are specified
in the <code>cats</code> argument of <code>fit()</code>, <code>generate()</code> or <code>predict()</code>.</p>
<p>GPs can be superimposed:</p>
<pre><code>gp = gp1 + gp2
</code></pre>
<h4 id="src.geostat.model.GP--examples">Examples</h4>
<p>A linear regression is a special case of GP regression that
can be modeled by Geostat. Suppose
$$
u_i = \beta_1 + \beta_2 x_i + \beta_3 y_i + \beta_4 x_i^2 \
    + \beta_5 x_i y_i + \beta_6 y_i^2 + \epsilon_i
$$
where <span class="arithmatex">\(u_i\)</span> is an observation, <span class="arithmatex">\(x_i\)</span> and <span class="arithmatex">\(y_i\)</span> are model
inputs, <span class="arithmatex">\(\epsilon_i \sim \mathcal{N}(0, \sigma^2)\)</span>
describes observation noise, and <span class="arithmatex">\(\beta_1, \ldots, \beta_6\)</span>
are regression coefficients.  Geostat can be used to fit this
regression (though not in the most efficient way):</p>
<pre><code class="language-python">@featurizer
def trend_terms(x, y):
    return 1, x, y, x*x, x*y, y*y
p = Parameters(beta=np.zeros([6]), sigma2=1.)
mean = mn.Trend(trend_terms, beta=p.beta)
kernel = krn.Noise(nugget=p.sigma2)
gp = GP(mean, kernel)
Model(gp).fit(locs, vals) # locs.shape = [N, 2], vals.shape = [N]
</code></pre>

              <details class="quote">
                <summary>Source code in <code>src/geostat/model.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">GP</span><span class="p">:</span>    
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gaussian Process (GP) model class with a mean function and a kernel.</span>

<span class="sd">    This class represents a Gaussian Process with specified mean</span>
<span class="sd">    and kernel functions.  If no mean is provided, a zero mean is</span>
<span class="sd">    used by default. The kernel must always be specified.  The class</span>
<span class="sd">    supports addition to combine two GP models, and it allows</span>
<span class="sd">    gathering variables from the mean and kernel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        mean (mean.Mean, optional):</span>
<span class="sd">            The mean function of the Gaussian Process. If not provided or set to 0, </span>
<span class="sd">            a ZeroTrend is used as the default mean.</span>

<span class="sd">        kernel (kernel.Kernel):</span>
<span class="sd">            The kernel function of the Gaussian Process. This parameter is required.</span>

<span class="sd">    Details</span>
<span class="sd">    -------</span>
<span class="sd">    This is how to specify a GP with a squared exponential kernel</span>
<span class="sd">    and superimposed uncorrelated noise:</span>
<span class="sd">    ```python</span>
<span class="sd">    import geostat.kernel as krn</span>
<span class="sd">    from geostat import GP, Model, Parameters</span>

<span class="sd">    p = Parameters(range=1., sill=1., nugget=1.)</span>
<span class="sd">    kernel = krn.SquaredExponential(range=p.range, sill=p.sill) + krn.Noise(nugget=p.nugget)</span>
<span class="sd">    gp = GP(0, kernel)</span>
<span class="sd">    ```</span>
<span class="sd">    To use the GP, it must be wrapped in a model:</span>
<span class="sd">    ```</span>
<span class="sd">    model = Model(GP)</span>
<span class="sd">    ```</span>
<span class="sd">    This model object can then be used to generate synthetic data,</span>
<span class="sd">    fit its parameters to provided data, or make predictions, see</span>
<span class="sd">    [`Model`](#src.geostat.model.Model).</span>

<span class="sd">    In Geostat, GPs can be defined on locations in Euclidean space</span>
<span class="sd">    of any dimension \(\mathbb{R}^D\), with the number of dimensions</span>
<span class="sd">    specified implicitly by the shape of the location matrix given</span>
<span class="sd">    to `fit()` or `generate()` in the `locs` argument.</span>

<span class="sd">    GPs can also be defined on locations in \(\mathbb{R}^D \times</span>
<span class="sd">    \mathbb{Z}\) using the [`Mix`](#src.geostat.model.Mix) operator.</span>
<span class="sd">    This construction is for modeling multiple spatial quantities,</span>
<span class="sd">    with each quantity occupying a different &#39;plane&#39; of the space.</span>
<span class="sd">    When multiple spatial quantities are involved, these are specified</span>
<span class="sd">    in the `cats` argument of `fit()`, `generate()` or `predict()`.</span>

<span class="sd">    GPs can be superimposed:</span>
<span class="sd">    ```</span>
<span class="sd">    gp = gp1 + gp2</span>
<span class="sd">    ```</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A linear regression is a special case of GP regression that</span>
<span class="sd">    can be modeled by Geostat. Suppose</span>
<span class="sd">    $$</span>
<span class="sd">    u_i = \beta_1 + \beta_2 x_i + \beta_3 y_i + \beta_4 x_i^2 \</span>
<span class="sd">        + \beta_5 x_i y_i + \beta_6 y_i^2 + \epsilon_i</span>
<span class="sd">    $$</span>
<span class="sd">    where \(u_i\) is an observation, \(x_i\) and \(y_i\) are model</span>
<span class="sd">    inputs, \(\epsilon_i \sim \mathcal{N}(0, \sigma^2)\)</span>
<span class="sd">    describes observation noise, and \(\beta_1, \ldots, \beta_6\)</span>
<span class="sd">    are regression coefficients.  Geostat can be used to fit this</span>
<span class="sd">    regression (though not in the most efficient way):</span>
<span class="sd">    ```python</span>
<span class="sd">    @featurizer</span>
<span class="sd">    def trend_terms(x, y):</span>
<span class="sd">        return 1, x, y, x*x, x*y, y*y</span>
<span class="sd">    p = Parameters(beta=np.zeros([6]), sigma2=1.)</span>
<span class="sd">    mean = mn.Trend(trend_terms, beta=p.beta)</span>
<span class="sd">    kernel = krn.Noise(nugget=p.sigma2)</span>
<span class="sd">    gp = GP(mean, kernel)</span>
<span class="sd">    Model(gp).fit(locs, vals) # locs.shape = [N, 2], vals.shape = [N]</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mean</span><span class="p">:</span> <span class="n">mn</span><span class="o">.</span><span class="n">Trend</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">krn</span><span class="o">.</span><span class="n">Kernel</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mn</span><span class="o">.</span><span class="n">ZeroTrend</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">GP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">kernel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__tf_tracing_type__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SingletonTraceType</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">gather_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div><hr />


<div class="doc doc-object doc-function">


<h2 id="src.geostat.model.Mix" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">src</span><span class="o">.</span><span class="n">geostat</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">Mix</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Linearly combines multiple Gaussian Processes (GPs) into a single GP using specified weights.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>inputs</code></td>
            <td>
                  <code>list of GPs</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of GP objects to be combined.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>weights</code></td>
            <td>
                  <code>matrix</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A matrix specifying how the inputs are to be combined. If not provided, 
an identity matrix is assumed, meaning the GPs are combined without weighting.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>GP</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="src.geostat.model.GP" href="#src.geostat.model.GP">GP</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A new GP object representing the linear combination of the input GPs with the specified weights.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Combining two GPs into a new multi-output GP:</p>
<p>Suppose you have two GPs: 
<span class="arithmatex">\(f_1(x) \sim \mathrm{GP}(\mu_1, K_1)\)</span> and <span class="arithmatex">\(f_2(x) \sim \mathrm{GP}(\mu_2, K_2)\)</span>, 
and you want to create a new multi-output GP <span class="arithmatex">\(\mathbf{g}(x)\)</span> defined as:</p>
<div class="arithmatex">\[
\mathbf{g}(x) = \begin{pmatrix}
g_1(x) \\
g_2(x) \\
g_3(x)
\end{pmatrix} = A \begin{pmatrix}
f_1(x) \\
f_2(x)
\end{pmatrix},
\]</div>
<p>where <span class="arithmatex">\(A\)</span> is the weights matrix. This can be implemented as:</p>
<pre><code>g = Mix([f1, f2], [[a11, a12], [a21, a22], [a31, a32]])
</code></pre>
<p>The resulting GP <span class="arithmatex">\(\mathbf{g}(x)\)</span> can then be used for fitting, generating, or predicting 
with methods such as <code>g.fit()</code>, <code>g.generate()</code>, or <code>g.predict()</code> and its components are specified using the <code>cats</code> parameter.</p>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>weights</code> parameter defines how the input GPs are linearly combined. If omitted, 
each GP is assumed to be independent, and the identity matrix is used.</li>
<li>The resulting GP supports all standard operations (e.g., <code>fit</code>, <code>generate</code>, <code>predict</code>).</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>src/geostat/model.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">Mix</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linearly combines multiple Gaussian Processes (GPs) into a single GP using specified weights.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        inputs (list of GPs):  </span>
<span class="sd">            A list of GP objects to be combined.</span>
<span class="sd">        weights (matrix, optional):  </span>
<span class="sd">            A matrix specifying how the inputs are to be combined. If not provided, </span>
<span class="sd">            an identity matrix is assumed, meaning the GPs are combined without weighting.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GP (GP):</span>
<span class="sd">            A new GP object representing the linear combination of the input GPs with the specified weights.</span>



<span class="sd">    Examples:</span>
<span class="sd">        Combining two GPs into a new multi-output GP:</span>

<span class="sd">        Suppose you have two GPs: </span>
<span class="sd">        \\(f_1(x) \sim \mathrm{GP}(\mu_1, K_1)\\) and \\(f_2(x) \sim \mathrm{GP}(\mu_2, K_2)\\), </span>
<span class="sd">        and you want to create a new multi-output GP \\(\mathbf{g}(x)\\) defined as:</span>

<span class="sd">        $$</span>
<span class="sd">        \mathbf{g}(x) = \\begin{pmatrix}</span>
<span class="sd">        g_1(x) \\\\</span>
<span class="sd">        g_2(x) \\\\</span>
<span class="sd">        g_3(x)</span>
<span class="sd">        \end{pmatrix} = A \\begin{pmatrix}</span>
<span class="sd">        f_1(x) \\\\</span>
<span class="sd">        f_2(x)</span>
<span class="sd">        \end{pmatrix},</span>
<span class="sd">        $$</span>

<span class="sd">        where \\(A\\) is the weights matrix. This can be implemented as:</span>

<span class="sd">        ```</span>
<span class="sd">        g = Mix([f1, f2], [[a11, a12], [a21, a22], [a31, a32]])</span>
<span class="sd">        ```</span>

<span class="sd">        The resulting GP \\(\mathbf{g}(x)\\) can then be used for fitting, generating, or predicting </span>
<span class="sd">        with methods such as `g.fit()`, `g.generate()`, or `g.predict()` and its components are specified using the `cats` parameter.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `weights` parameter defines how the input GPs are linearly combined. If omitted, </span>
<span class="sd">        each GP is assumed to be independent, and the identity matrix is used.</span>
<span class="sd">        - The resulting GP supports all standard operations (e.g., `fit`, `generate`, `predict`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">GP</span><span class="p">(</span>
        <span class="n">mn</span><span class="o">.</span><span class="n">Mix</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">mean</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span> <span class="n">weights</span><span class="p">),</span> 
        <span class="n">krn</span><span class="o">.</span><span class="n">Mix</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">kernel</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span> <span class="n">weights</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><hr />


<div class="doc doc-object doc-class">



<h2 id="src.geostat.model.Model" class="doc doc-heading">
            <code>src.geostat.model.Model</code>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents first">


        <p>Model class for performing Gaussian Process (GP) training and prediction with optional warping.</p>
<p>The <code>Model</code> class integrates a GP model with optional data warping, and supports data generation on given location,
training on given location and observation data, and prediction on given location.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>gp</code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.geostat.model.GP" href="#src.geostat.model.GP">GP</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Gaussian Process model to be used for training and prediction.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>warp</code></td>
            <td>
                  <code><span title="src.geostat.model.Warp">Warp</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional warping transformation applied to the data. If not specified, <code>NoWarp</code> 
is used by default.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>parameter_sample_size</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of parameter samples to draw. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>locs</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing location data.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>vals</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing observed values corresponding to <code>locs</code>.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>cats</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing categorical data.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>report</code></td>
            <td>
                  <code><span title="typing.Callable">Callable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A custom reporting function to display model parameters. If not provided, a default 
reporting function is used.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to print model parameters and status updates. Default is True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>
        <h4 id="src.geostat.model.Model--details">Details</h4>
<p>To generate synthetic data at <span class="arithmatex">\(n\)</span> locations in <span class="arithmatex">\(k\)</span>-dimensional
space, pass the locations into <code>generate()</code>:</p>
<pre><code>vals = model.generate(locs) # locs has shape (n, k).
</code></pre>
<p>To fit to data at <span class="arithmatex">\(n\)</span> locations, pass locations and values into
<code>fit()</code>:
```</p>
<h4 id="src.geostat.model.Model--examples">Examples</h4>
<p>Initializing a <code>Model</code> with a Gaussian Process:</p>
<pre><code>```
from geostat import GP, Model, Parameters
from geostat.kernel import Noise
import numpy as np

# Create parameters.
p = Parameters(nugget=1.)

# Define the Gaussian Process and the model
gp = GP(kernel=Noise(nugget=p.nugget))
locs = np.array([[0.0, 1.0], [1.0, 2.0]])
vals = np.array([1.0, 2.0])
model = Model(gp=gp, locs=locs, vals=vals)
```
</code></pre>
<p>Notes:
    - The <code>__post_init__</code> method sets up default values, initializes the warping if not provided, 
    and sets up reporting and data preprocessing.</p>

              <details class="quote">
                <summary>Source code in <code>src/geostat/model.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Model</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Model class for performing Gaussian Process (GP) training and prediction with optional warping.</span>

<span class="sd">    The `Model` class integrates a GP model with optional data warping, and supports data generation on given location,</span>
<span class="sd">    training on given location and observation data, and prediction on given location.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        gp (GP):</span>
<span class="sd">            The Gaussian Process model to be used for training and prediction.</span>
<span class="sd">        warp (Warp, optional):</span>
<span class="sd">            An optional warping transformation applied to the data. If not specified, `NoWarp` </span>
<span class="sd">            is used by default.</span>
<span class="sd">        parameter_sample_size (int, optional):</span>
<span class="sd">            The number of parameter samples to draw. Default is None.</span>
<span class="sd">        locs (np.ndarray, optional):</span>
<span class="sd">            A NumPy array containing location data.</span>
<span class="sd">        vals (np.ndarray, optional):</span>
<span class="sd">            A NumPy array containing observed values corresponding to `locs`.</span>
<span class="sd">        cats (np.ndarray, optional):</span>
<span class="sd">            A NumPy array containing categorical data.</span>
<span class="sd">        report (Callable, optional):</span>
<span class="sd">            A custom reporting function to display model parameters. If not provided, a default </span>
<span class="sd">            reporting function is used.</span>
<span class="sd">        verbose (bool, optional):</span>
<span class="sd">            Whether to print model parameters and status updates. Default is True.</span>

<span class="sd">    Details</span>
<span class="sd">    -------</span>
<span class="sd">    To generate synthetic data at \(n\) locations in \(k\)-dimensional</span>
<span class="sd">    space, pass the locations into `generate()`:</span>
<span class="sd">    ```</span>
<span class="sd">    vals = model.generate(locs) # locs has shape (n, k).</span>
<span class="sd">    ```</span>

<span class="sd">    To fit to data at \(n\) locations, pass locations and values into</span>
<span class="sd">    `fit()`:</span>
<span class="sd">    ```</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Initializing a `Model` with a Gaussian Process:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat import GP, Model, Parameters</span>
<span class="sd">        from geostat.kernel import Noise</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        # Create parameters.</span>
<span class="sd">        p = Parameters(nugget=1.)</span>

<span class="sd">        # Define the Gaussian Process and the model</span>
<span class="sd">        gp = GP(kernel=Noise(nugget=p.nugget))</span>
<span class="sd">        locs = np.array([[0.0, 1.0], [1.0, 2.0]])</span>
<span class="sd">        vals = np.array([1.0, 2.0])</span>
<span class="sd">        model = Model(gp=gp, locs=locs, vals=vals)</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `__post_init__` method sets up default values, initializes the warping if not provided, </span>
<span class="sd">        and sets up reporting and data preprocessing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gp</span><span class="p">:</span> <span class="n">GP</span>
    <span class="n">warp</span><span class="p">:</span> <span class="n">Warp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">parameter_sample_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">locs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">vals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">cats</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">report</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># &#39;&#39;&#39;</span>
        <span class="c1"># Parameters:</span>
        <span class="c1">#         x : Pandas DataFrame with columns for locations.</span>

        <span class="c1">#         u : A Pandas Series containing observations.</span>

        <span class="c1">#         featurization : function, optional</span>
        <span class="c1">#             Should be a function that takes x1 (n-dim array of input data)</span>
        <span class="c1">#             and returns the coordinates, i.e., x, y, x**2, y**2.</span>
        <span class="c1">#             Example: def featurization(x1):</span>
        <span class="c1">#                         return x1[:, 0], x1[:, 1], x1[:, 0]**2, x1[:, 1]**2.</span>
        <span class="c1">#             Default is None.</span>

        <span class="c1">#         latent : List[GP]</span>
        <span class="c1">#              Name of the covariance function to use in the GP.</span>
        <span class="c1">#              Should be &#39;squared-exp&#39; or &#39;gamma-exp&#39;.</span>
        <span class="c1">#              Default is &#39;squared-exp&#39;.</span>

        <span class="c1">#         verbose : boolean, optional</span>
        <span class="c1">#             Whether or not to print parameters.</span>
        <span class="c1">#             Default is True.</span>

        <span class="c1"># Performs Gaussian process training and prediction.</span>
        <span class="c1"># &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span> <span class="o">=</span> <span class="n">NoWarp</span><span class="p">()</span>

        <span class="c1"># Default reporting function.</span>
        <span class="k">def</span> <span class="nf">default_report</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{:5d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{:5.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;floatkind&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{:5.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">}):</span>
                        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">fmt</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">report</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">report</span> <span class="o">=</span> <span class="n">default_report</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">)</span>

        <span class="c1"># Collect parameters and create TF parameters.</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">create_tf_variable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">gather_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values of the model&#39;s parameters based on the provided keyword arguments.</span>
<span class="sd">        Each parameter specified must exist in the model; otherwise, a `ValueError` is raised.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            values (keyword arguments):</span>
<span class="sd">                A dictionary of parameter names and their corresponding values that should be </span>
<span class="sd">                set in the model. Each key corresponds to a parameter name, and the value is </span>
<span class="sd">                the value to be assigned to that parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self (Model):</span>
<span class="sd">                The model instance with updated parameter values, allowing for method chaining.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError:</span>
<span class="sd">                If a provided parameter name does not exist in the model&#39;s parameters.</span>

<span class="sd">        Examples:</span>
<span class="sd">            Update parameter value using `set`:</span>

<span class="sd">            ```</span>
<span class="sd">            from geostat import GP, Model, Parameters</span>
<span class="sd">            from geostat.kernel import Noise</span>

<span class="sd">            # Create parameters.</span>
<span class="sd">            p = Parameters(nugget=1.)</span>

<span class="sd">            # Create model</span>
<span class="sd">            kernel = Noise(nugget=p.nugget)</span>
<span class="sd">            model = Model(GP(0, kernel))</span>

<span class="sd">            # Update parameters</span>
<span class="sd">            model.set(nugget=0.5)</span>
<span class="sd">            ```</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The `set` method retrieves the current parameters using `gather_vars` and updates </span>
<span class="sd">            their values. The associated TensorFlow variables are also recreated.</span>
<span class="sd">            - This method is useful for dynamically updating the model&#39;s parameters after initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">create_tf_variable</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not a parameter&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trains the model using the provided location and value data by optimizing the parameters of the Gaussian Process (GP)</span>
<span class="sd">        using the Adam optimizer. Optionally performs regularization and can handle categorical data.</span>

<span class="sd">        Parameters:        </span>
<span class="sd">            locs (np.ndarray):</span>
<span class="sd">                A NumPy array containing the input locations for training.</span>
<span class="sd">            vals (np.ndarray):</span>
<span class="sd">                A NumPy array containing observed values corresponding to the `locs`.</span>
<span class="sd">            cats (np.ndarray, optional):</span>
<span class="sd">                A NumPy array containing categorical data for each observation in `locs`. If provided,</span>
<span class="sd">                the data is sorted according to `cats` to enable stratified training. Defaults to None.</span>
<span class="sd">            step_size (float, optional):</span>
<span class="sd">                The learning rate for the Adam optimizer.</span>
<span class="sd">            iters (int, optional):</span>
<span class="sd">                The total number of iterations to run for training.</span>
<span class="sd">            reg (float or None, optional):</span>
<span class="sd">                Regularization penalty parameter. If None, no regularization is applied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self (Model):</span>
<span class="sd">                The model instance with updated parameters, allowing for method chaining.</span>

<span class="sd">        Examples:</span>
<span class="sd">            Fitting a model using training data:</span>

<span class="sd">            ```</span>
<span class="sd">            from geostat import GP, Model, Parameters</span>
<span class="sd">            from geostat.kernel import Noise</span>
<span class="sd">            import numpy as np</span>

<span class="sd">            # Create parameters.</span>
<span class="sd">            p = Parameters(nugget=1.)</span>

<span class="sd">            # Create model</span>
<span class="sd">            kernel = Noise(nugget=p.nugget)</span>
<span class="sd">            model = Model(GP(0, kernel))</span>

<span class="sd">            # Fit model</span>
<span class="sd">            locs = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]])</span>
<span class="sd">            vals = np.array([10.0, 15.0, 20.0])</span>
<span class="sd">            model.fit(locs, vals, step_size=0.05, iters=500)</span>
<span class="sd">            # [iter    50 ll -63.71 time  2.72 reg  0.00 nugget  6.37]</span>
<span class="sd">            # [iter   100 ll -32.94 time  0.25 reg  0.00 nugget 13.97]</span>
<span class="sd">            # [iter   150 ll -23.56 time  0.25 reg  0.00 nugget 22.65]</span>
<span class="sd">            # [iter   200 ll -19.26 time  0.25 reg  0.00 nugget 32.27]</span>
<span class="sd">            # [iter   250 ll -16.92 time  0.25 reg  0.00 nugget 42.63]</span>
<span class="sd">            # [iter   300 ll -15.52 time  0.24 reg  0.00 nugget 53.50]</span>
<span class="sd">            # [iter   350 ll -14.63 time  0.24 reg  0.00 nugget 64.71]</span>
<span class="sd">            # [iter   400 ll -14.03 time  0.24 reg  0.00 nugget 76.10]</span>
<span class="sd">            # [iter   450 ll -13.61 time  0.25 reg  0.00 nugget 87.52]</span>
<span class="sd">            # [iter   500 ll -13.32 time  0.24 reg  0.00 nugget 98.85]</span>
<span class="sd">            ```</span>

<span class="sd">            Using categorical data for training:</span>

<span class="sd">            ```</span>
<span class="sd">            cats = np.array([1, 1, 2])</span>
<span class="sd">            model.fit(locs, vals, cats=cats, step_size=0.01, iters=300)</span>
<span class="sd">            # [iter    30 ll -12.84 time  0.25 reg  0.00 nugget 131.53]</span>
<span class="sd">            # [iter    60 ll -12.62 time  0.15 reg  0.00 nugget 164.41]</span>
<span class="sd">            # [iter    90 ll -12.53 time  0.16 reg  0.00 nugget 191.70]</span>
<span class="sd">            # [iter   120 ll -12.50 time  0.16 reg  0.00 nugget 211.74]</span>
<span class="sd">            # [iter   150 ll -12.49 time  0.15 reg  0.00 nugget 225.07]</span>
<span class="sd">            # [iter   180 ll -12.49 time  0.16 reg  0.00 nugget 233.15]</span>
<span class="sd">            # [iter   210 ll -12.49 time  0.15 reg  0.00 nugget 237.64]</span>
<span class="sd">            # [iter   240 ll -12.49 time  0.15 reg  0.00 nugget 239.92]</span>
<span class="sd">            # [iter   270 ll -12.49 time  0.15 reg  0.00 nugget 240.98]</span>
<span class="sd">            # [iter   300 ll -12.49 time  0.15 reg  0.00 nugget 241.42]</span>
<span class="sd">            ```</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The `fit` method uses the Adam optimizer to minimize the negative log-likelihood (`ll`) and any regularization </span>
<span class="sd">            penalties specified by `reg`.</span>
<span class="sd">            - During training, if `cats` are provided, data points are sorted according to `cats` to ensure grouped training.</span>
<span class="sd">            - The `verbose` flag determines whether training progress is printed after each iteration.</span>
<span class="sd">            - After training, parameter values are saved and can be accessed or updated using the model&#39;s attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Collect parameters and create TF parameters.</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span>

        <span class="c1"># Permute datapoints if cats is given.</span>
        <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
            <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Data dict.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;warplocs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs</span><span class="p">),</span>
            <span class="s1">&#39;vals&#39;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="s1">&#39;cats&#39;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>

        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">step_size</span><span class="p">)</span>

        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Iteration count.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">iters</span> <span class="o">/</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">ll</span><span class="p">,</span> <span class="n">reg_penalty</span> <span class="o">=</span> <span class="n">gp_train_step</span><span class="p">(</span>
                    <span class="n">optimizer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">time_elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                  <span class="nb">dict</span><span class="p">(</span><span class="nb">iter</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">ll</span><span class="o">=</span><span class="n">ll</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time_elapsed</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="n">reg_penalty</span><span class="p">)</span> <span class="o">|</span>
                  <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">surface</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()})</span>

        <span class="c1"># Save parameter values.</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">update_value</span><span class="p">()</span>

        <span class="c1"># Restore order if things were permuted.</span>
        <span class="k">if</span> <span class="n">perm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
            <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">revperm</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cats</span> <span class="o">=</span> <span class="n">cats</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">mcmc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">move_prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">burnin</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">report_interval</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>

        <span class="k">assert</span> <span class="n">samples</span> <span class="o">%</span> <span class="n">report_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;`samples` must be a multiple of `report_interval`&#39;</span>
        <span class="k">assert</span> <span class="n">burnin</span> <span class="o">%</span> <span class="n">report_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;`burnin` must be a multiple of `report_interval`&#39;</span>

        <span class="c1"># Permute datapoints if cats is given.</span>
        <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
            <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>

        <span class="c1"># Data dict.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;locs&#39;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="s1">&#39;vals&#39;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="s1">&#39;cats&#39;</span><span class="p">:</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>

        <span class="c1"># Initial MCMC state.</span>
        <span class="n">initial_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_space</span><span class="o">.</span><span class="n">get_underlying</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="c1"># Unnormalized log posterior distribution.</span>
        <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">up</span><span class="p">):</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_space</span><span class="o">.</span><span class="n">get_surface</span><span class="p">(</span><span class="n">up</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gp_log_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">up_flat</span><span class="p">):</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">pack_sequence_as</span><span class="p">(</span><span class="n">initial_up</span><span class="p">,</span> <span class="n">up_flat</span><span class="p">)</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">map_fn</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">fn_output_signature</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="c1"># log_prior = -tf.reduce_sum(tf.math.log(1. + tf.square(up_flat)), axis=0)</span>
            <span class="k">return</span> <span class="n">ll</span> <span class="c1"># + log_prior</span>

        <span class="c1"># Run the chain for a burst.</span>
        <span class="nd">@tf</span><span class="o">.</span><span class="n">function</span>
        <span class="k">def</span> <span class="nf">run_chain</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">final_results</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">iters</span><span class="p">):</span>
            <span class="n">samples</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">final_results</span> <span class="o">=</span> <span class="n">tfp</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">sample_chain</span><span class="p">(</span>
                <span class="n">num_results</span><span class="o">=</span><span class="n">iters</span><span class="p">,</span>
                <span class="n">current_state</span><span class="o">=</span><span class="n">current_state</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
                <span class="n">return_final_kernel_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">trace_fn</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="n">results</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">final_results</span>

        <span class="k">def</span> <span class="nf">new_state_fn</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
          <span class="n">direction_dist</span> <span class="o">=</span> <span class="n">tfd</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">dtype</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">dtype</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
          <span class="n">scale_dist</span> <span class="o">=</span> <span class="n">tfd</span><span class="o">.</span><span class="n">Exponential</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">dtype</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">scale</span><span class="p">))</span>
          <span class="n">pick_dist</span> <span class="o">=</span> <span class="n">tfd</span><span class="o">.</span><span class="n">Bernoulli</span><span class="p">(</span><span class="n">probs</span><span class="o">=</span><span class="n">move_prob</span><span class="p">)</span>

          <span class="k">def</span> <span class="nf">_fn</span><span class="p">(</span><span class="n">state_parts</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
            <span class="n">next_state_parts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">part_seeds</span> <span class="o">=</span> <span class="n">tfp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split_seed</span><span class="p">(</span>
                <span class="n">seed</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">state_parts</span><span class="p">),</span> <span class="n">salt</span><span class="o">=</span><span class="s1">&#39;rwmcauchy&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ps</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">state_parts</span><span class="p">,</span> <span class="n">part_seeds</span><span class="p">):</span>
                <span class="n">pick</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pick_dist</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">sample_shape</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">ps</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">direction_dist</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">sample_shape</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>
                <span class="n">scale_val</span> <span class="o">=</span> <span class="n">scale_dist</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>
                <span class="n">next_state_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;a...,a-&gt;a...&#39;</span><span class="p">,</span> <span class="n">pick</span> <span class="o">*</span> <span class="n">direction</span><span class="p">,</span> <span class="n">scale_val</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">next_state_parts</span>
          <span class="k">return</span> <span class="n">_fn</span>

        <span class="n">inv_temps</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">make_kernel_fn</span><span class="p">(</span><span class="n">target_log_prob_fn</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tfp</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">RandomWalkMetropolis</span><span class="p">(</span>
                <span class="n">target_log_prob_fn</span><span class="o">=</span><span class="n">target_log_prob_fn</span><span class="p">,</span>
                <span class="n">new_state_fn</span><span class="o">=</span><span class="n">new_state_fn</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">step_size</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inv_temps</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

        <span class="n">kernel</span> <span class="o">=</span> <span class="n">tfp</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">ReplicaExchangeMC</span><span class="p">(</span>
            <span class="n">target_log_prob_fn</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
            <span class="n">inverse_temperatures</span><span class="o">=</span><span class="n">inv_temps</span><span class="p">,</span>
            <span class="n">make_kernel_fn</span><span class="o">=</span><span class="n">make_kernel_fn</span><span class="p">)</span>

        <span class="c1"># Do bursts.</span>
        <span class="n">current_state</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">initial_up</span><span class="p">)</span>
        <span class="n">final_results</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">acc_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_bursts</span> <span class="o">=</span> <span class="p">(</span><span class="n">samples</span> <span class="o">+</span> <span class="n">burnin</span><span class="p">)</span> <span class="o">//</span> <span class="n">report_interval</span>
        <span class="n">burnin_bursts</span> <span class="o">=</span> <span class="n">burnin</span> <span class="o">//</span> <span class="n">report_interval</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bursts</span><span class="p">):</span>
            <span class="n">is_burnin</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">burnin_bursts</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">burnin_bursts</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;BURNIN</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">is_burnin</span> <span class="k">else</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">SAMPLING&#39;</span><span class="p">)</span>

            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">final_results</span> <span class="o">=</span> <span class="n">run_chain</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">final_results</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">report_interval</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_burnin</span><span class="p">:</span> <span class="nb">print</span><span class="p">()</span>
                <span class="n">accept_rates</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">post_swap_replica_results</span><span class="o">.</span><span class="n">is_accepted</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[iter </span><span class="si">{:4d}</span><span class="s1">] [time </span><span class="si">{:.1f}</span><span class="s1">] [accept rates </span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="p">((</span><span class="n">i</span> <span class="k">if</span> <span class="n">is_burnin</span> <span class="k">else</span> <span class="n">i</span> <span class="o">-</span> <span class="n">burnin_bursts</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">report_interval</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                    <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">accept_rates</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_burnin</span><span class="p">:</span>
                <span class="n">acc_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">states</span><span class="p">))</span>
                <span class="n">all_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">acc_states</span><span class="p">)]</span>
                <span class="n">up</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">pack_sequence_as</span><span class="p">(</span><span class="n">initial_up</span><span class="p">,</span> <span class="n">all_states</span><span class="p">)</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_space</span><span class="o">.</span><span class="n">get_surface</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 

                <span class="c1"># Reporting</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">95</span><span class="p">]:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">sp</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s1">02d</span><span class="si">}</span><span class="s1">%ile&#39;</span><span class="p">)</span>

            <span class="n">current_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span><span class="p">]</span>

        <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_space</span><span class="o">.</span><span class="n">get_surface</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Restore order if things were permuted.</span>
        <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
            <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">revperm</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">parameters</span><span class="o">=</span><span class="n">posterior</span><span class="p">,</span>
            <span class="n">parameter_sample_size</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">locs</span><span class="o">=</span><span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span> <span class="n">cats</span><span class="o">=</span><span class="n">cats</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">cats</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates synthetic data values from the Gaussian Process (GP) model based on the provided location data.</span>
<span class="sd">        This method simulates values based on the GP&#39;s covariance structure, allowing for random sample generation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            locs (np.ndarray):</span>
<span class="sd">                A NumPy array containing the input locations for which to generate synthetic values.</span>
<span class="sd">            cats (np.ndarray, optional):</span>
<span class="sd">                A NumPy array containing categorical data corresponding to `locs`. If provided, data points </span>
<span class="sd">                are permuted according to `cats` for stratified generation. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self (Model):</span>
<span class="sd">                The model instance with generated values stored in `self.vals` and corresponding locations stored </span>
<span class="sd">                in `self.locs`. This enables method chaining.</span>

<span class="sd">        Examples:</span>
<span class="sd">            Generating synthetic values for a set of locations:</span>

<span class="sd">            ```</span>
<span class="sd">            from geostat import GP, Model, Parameters</span>
<span class="sd">            from geostat.kernel import Noise</span>
<span class="sd">            import numpy as np</span>

<span class="sd">            # Create parameters.</span>
<span class="sd">            p = Parameters(nugget=1.)</span>

<span class="sd">            # Create model</span>
<span class="sd">            kernel = Noise(nugget=p.nugget)</span>
<span class="sd">            model = Model(GP(0, kernel))</span>

<span class="sd">            # Generate values based on locs</span>
<span class="sd">            locs = np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])</span>
<span class="sd">            model.generate(locs)</span>
<span class="sd">            generated_vals = model.vals  # Access the generated values</span>
<span class="sd">            print(generated_vals)</span>
<span class="sd">            # [0.45151083 1.23276189 0.3822659 ] (Values are non-deterministic)</span>
<span class="sd">            ```</span>

<span class="sd">        Notes:</span>
<span class="sd">            - Conditional generation is currently not supported, and this method will raise an assertion error if </span>
<span class="sd">            `self.locs` and `self.vals` are already defined.</span>
<span class="sd">            - Generation from a distribution is not yet supported, and an assertion error will be raised if </span>
<span class="sd">            `self.parameter_sample_size` is not `None`.</span>
<span class="sd">            - If `cats` are provided, the data is permuted according to `cats` for stratified generation, and </span>
<span class="sd">            the original order is restored before returning.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Conditional generation not yet supported&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Generation from a distribution not yet supported&#39;</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>

        <span class="c1"># Permute datapoints if cats is given.</span>
        <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
            <span class="n">locs</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">m</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">({}),</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="n">MVN</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">S</span><span class="p">))</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="c1"># Restore order if things were permuted.</span>
        <span class="k">if</span> <span class="n">perm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
            <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">revperm</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cats</span> <span class="o">=</span> <span class="n">cats</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">subsample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduce</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tracker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs Gaussian Process (GP) predictions of the mean and variance for the given location data.</span>
<span class="sd">        Supports batch predictions for large datasets and can handle categorical data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            locs2 (np.ndarray):</span>
<span class="sd">                A NumPy array containing the input locations for which predictions are to be made.</span>
<span class="sd">            cats2 (np.ndarray, optional):</span>
<span class="sd">                A NumPy array containing categorical data for the prediction locations (`locs2`). If provided,</span>
<span class="sd">                the data points will be permuted according to `cats2`. Default is None.</span>
<span class="sd">            subsample (int, optional):</span>
<span class="sd">                Specifies the number of parameter samples to be used for prediction when `parameter_sample_size` is set.</span>
<span class="sd">                Only valid if parameters are sampled. Default is None.</span>
<span class="sd">            reduce (str, optional):</span>
<span class="sd">                Specifies the reduction method (&#39;mean&#39; or &#39;median&#39;) to aggregate predictions from multiple parameter samples.</span>
<span class="sd">                Only valid if parameters are sampled. Default is None.</span>
<span class="sd">            tracker (Callable, optional):</span>
<span class="sd">                A tracking function for monitoring progress when making predictions across multiple samples. Default is None.</span>
<span class="sd">            pair (bool, optional):</span>
<span class="sd">                If True, performs pairwise predictions of mean and variance for each pair of input points in `locs2`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            m (np.ndarray):</span>
<span class="sd">                The predicted mean values for the input locations.</span>
<span class="sd">            v (np.ndarray):</span>
<span class="sd">                The predicted variances for the input locations.</span>

<span class="sd">        Examples:</span>
<span class="sd">            Making predictions for a set of locations:</span>

<span class="sd">            ```</span>
<span class="sd">            from geostat import GP, Model, Parameters</span>
<span class="sd">            from geostat.kernel import SquaredExponential</span>
<span class="sd">            import numpy as np</span>

<span class="sd">            # Create parameters.</span>
<span class="sd">            p = Parameters(sill=1.0, range=2.0)</span>

<span class="sd">            # Create model</span>
<span class="sd">            kernel = SquaredExponential(sill=p.sill, range=p.range)</span>
<span class="sd">            model = Model(GP(0, kernel))</span>

<span class="sd">            # Fit model</span>
<span class="sd">            locs = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]])</span>
<span class="sd">            vals = np.array([10.0, 15.0, 20.0])</span>
<span class="sd">            model.fit(locs, vals, step_size=0.05, iters=500)</span>
<span class="sd">            # [iter    50 ll -40.27 time  2.29 reg  0.00 sill  6.35 range  1.96]</span>
<span class="sd">            # [iter   100 ll -21.79 time  0.40 reg  0.00 sill 13.84 range  2.18]</span>
<span class="sd">            # [iter   150 ll -16.17 time  0.39 reg  0.00 sill 22.31 range  2.44]</span>
<span class="sd">            # [iter   200 ll -13.55 time  0.39 reg  0.00 sill 31.75 range  2.76]</span>
<span class="sd">            # [iter   250 ll -12.08 time  0.38 reg  0.00 sill 42.08 range  3.12]</span>
<span class="sd">            # [iter   300 ll -11.14 time  0.38 reg  0.00 sill 53.29 range  3.48]</span>
<span class="sd">            # [iter   350 ll -10.50 time  0.38 reg  0.00 sill 65.36 range  3.85]</span>
<span class="sd">            # [iter   400 ll -10.05 time  0.39 reg  0.00 sill 78.29 range  4.22]</span>
<span class="sd">            # [iter   450 ll -9.70 time  0.39 reg  0.00 sill 92.07 range  4.59]</span>
<span class="sd">            # [iter   500 ll -9.43 time  0.39 reg  0.00 sill 106.70 range  4.95]</span>

<span class="sd">            # Run predictions</span>
<span class="sd">            locs2 = np.array([[1.5, 1.5], [2.5, 4.0]])</span>
<span class="sd">            mean, variance = model.predict(locs2)</span>
<span class="sd">            print(mean)</span>
<span class="sd">            # [ 9.89839798 18.77077269]</span>
<span class="sd">            print(variance)</span>
<span class="sd">            # [2.1572128  0.54444738]</span>
<span class="sd">            ```</span>

<span class="sd">        Notes:</span>
<span class="sd">            - If `subsample` is specified, it should be used only when `parameter_sample_size` is defined.</span>
<span class="sd">            - The `reduce` parameter allows aggregation of predictions, but it&#39;s valid only with sampled parameters.</span>
<span class="sd">            - The method supports pairwise predictions by setting `pair=True`, which is useful for predicting </span>
<span class="sd">            the covariance between two sets of locations.</span>
<span class="sd">            - The internal `interpolate_batch` and `interpolate_pair_batch` functions handle the prediction computations</span>
<span class="sd">            in a batched manner to support large datasets efficiently.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">subsample</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
            <span class="s1">&#39;`subsample` is only valid with sampled parameters&#39;</span>

        <span class="k">assert</span> <span class="n">reduce</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
            <span class="s1">&#39;`reduce` is only valid with sampled parameters&#39;</span>

        <span class="k">assert</span> <span class="n">subsample</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">reduce</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> \
            <span class="s1">&#39;`subsample` and `reduce` cannot both be given&#39;</span>

        <span class="k">if</span> <span class="n">tracker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tracker</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">locs2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;Mismatch in location dimensions&#39;</span>
        <span class="k">if</span> <span class="n">cats2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">cats2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">locs2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;Mismatched shapes in cats and locs&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cats2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">locs2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">interpolate_batch</span><span class="p">(</span><span class="n">A11i</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">vals1diff</span><span class="p">,</span> <span class="n">cats1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Inputs:</span>
<span class="sd">              locs1.shape = [N1, K]</span>
<span class="sd">              vals1diff.shape = [N1]</span>
<span class="sd">              cats1.shape = [N1]</span>
<span class="sd">              locs2.shape = [N2, K]</span>
<span class="sd">              cats2.shape = [N2]</span>

<span class="sd">            Outputs:</span>
<span class="sd">              u2_mean.shape = [N2]</span>
<span class="sd">              u2_var.shape = [N2]</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">N1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs1</span><span class="p">)</span> <span class="c1"># Number of measurements.</span>

            <span class="c1"># Permute datapoints if cats is given.</span>
            <span class="k">if</span> <span class="n">cats2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats2</span><span class="p">)</span>
                <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span> <span class="o">=</span> <span class="n">locs2</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats2</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
                <span class="n">locs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">({})</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">A12</span> <span class="o">=</span> <span class="n">gp_covariance2</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">N1</span><span class="p">)</span>

            <span class="n">m2</span><span class="p">,</span> <span class="n">A22</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

            <span class="c1"># Restore order if things were permuted.</span>
            <span class="k">if</span> <span class="n">cats2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">revperm</span><span class="p">)</span>
                <span class="n">A12</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">revperm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">A22</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">A22</span><span class="p">,</span> <span class="n">revperm</span><span class="p">),</span> <span class="n">revperm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">u2_mean</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,a-&gt;b&#39;</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,b-&gt;a&#39;</span><span class="p">,</span> <span class="n">A11i</span><span class="p">,</span> <span class="n">vals1diff</span><span class="p">))</span>
            <span class="n">u2_var</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">diag_part</span><span class="p">(</span><span class="n">A22</span><span class="p">)</span> <span class="o">-</span>  <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,ab-&gt;b&#39;</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A11i</span><span class="p">,</span> <span class="n">A12</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">u2_mean</span><span class="p">,</span> <span class="n">u2_var</span>

        <span class="k">def</span> <span class="nf">interpolate_pair_batch</span><span class="p">(</span><span class="n">A11i</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">vals1diff</span><span class="p">,</span> <span class="n">cats1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Inputs:</span>
<span class="sd">              locs1.shape = [N1, K]</span>
<span class="sd">              vals1diff.shape = [N1]</span>
<span class="sd">              cats1.shape = [N1]</span>
<span class="sd">              locs2.shape = [N2, 2, K]</span>
<span class="sd">              cats2.shape = [N2]</span>

<span class="sd">            Outputs:</span>
<span class="sd">              u2_mean.shape = [N2, 2]</span>
<span class="sd">              u2_var.shape = [N2, 2, 2]</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">N1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs1</span><span class="p">)</span> <span class="c1"># Number of measurements.</span>
            <span class="n">N2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs2</span><span class="p">)</span> <span class="c1"># Number of prediction pairs.</span>

            <span class="c1"># Permute datapoints if cats is given.</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats2</span><span class="p">)</span>
            <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span> <span class="o">=</span> <span class="n">locs2</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats2</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>

            <span class="c1"># Warp locs2.</span>
            <span class="n">locs2_shape</span> <span class="o">=</span> <span class="n">locs2</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">locs2</span> <span class="o">=</span> <span class="n">locs2</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">locs2_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>  <span class="c1"># Shape into matrix.</span>
            <span class="n">locs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">({})</span>
            <span class="n">locs2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">locs2</span><span class="p">,</span> <span class="n">locs2_shape</span><span class="p">)</span>  <span class="c1"># Revert shape.</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">A12</span> <span class="o">=</span> <span class="n">gp_covariance2</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">N1</span><span class="p">)</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">A13</span> <span class="o">=</span> <span class="n">gp_covariance2</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">N1</span><span class="p">)</span>

            <span class="n">m2</span><span class="p">,</span> <span class="n">A22</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

            <span class="n">m3</span><span class="p">,</span> <span class="n">A33</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">A23</span> <span class="o">=</span> <span class="n">gp_covariance2</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">N2</span><span class="p">)</span>

            <span class="c1"># Reassemble into more useful shapes.</span>

            <span class="n">A12</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">A12</span><span class="p">,</span> <span class="n">A13</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [N1, N2, 2]</span>

            <span class="n">m2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">m2</span><span class="p">,</span> <span class="n">m3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [N2, 2]</span>

            <span class="n">A22</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">diag_part</span><span class="p">(</span><span class="n">A22</span><span class="p">)</span>
            <span class="n">A33</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">diag_part</span><span class="p">(</span><span class="n">A33</span><span class="p">)</span>
            <span class="n">A23</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">diag_part</span><span class="p">(</span><span class="n">A23</span><span class="p">)</span>
            <span class="n">A22</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">A22</span><span class="p">,</span> <span class="n">A23</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">A23</span><span class="p">,</span> <span class="n">A33</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># [N2, 2, 2]</span>

            <span class="c1"># Restore order if things were permuted.</span>
            <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">revperm</span><span class="p">)</span>
            <span class="n">A12</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">revperm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">A22</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">A22</span><span class="p">,</span> <span class="n">revperm</span><span class="p">)</span>

            <span class="n">u2_mean</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abc,a-&gt;bc&#39;</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,b-&gt;a&#39;</span><span class="p">,</span> <span class="n">A11i</span><span class="p">,</span> <span class="n">vals1diff</span><span class="p">))</span>
            <span class="n">u2_var</span> <span class="o">=</span> <span class="n">A22</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abc,abd-&gt;bcd&#39;</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ae,ebd-&gt;abd&#39;</span><span class="p">,</span> <span class="n">A11i</span><span class="p">,</span> <span class="n">A12</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">u2_mean</span><span class="p">,</span> <span class="n">u2_var</span>

        <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">vals1</span><span class="p">,</span> <span class="n">cats1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Interpolate in batches.</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="n">locs1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="n">for_gp</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs2</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">batch_size</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="n">locs2</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">],</span> <span class="n">cats2</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
                <span class="n">for_gp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>

            <span class="c1"># Permute datapoints if cats is given.</span>
            <span class="k">if</span> <span class="n">cats1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats1</span><span class="p">)</span>
                <span class="n">locs1</span><span class="p">,</span> <span class="n">vals1</span><span class="p">,</span> <span class="n">cats1</span> <span class="o">=</span> <span class="n">locs1</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">vals1</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats1</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>

            <span class="n">locs1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs1</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">({})</span>

            <span class="n">m1</span><span class="p">,</span> <span class="n">A11</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

            <span class="n">A11i</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A11</span><span class="p">)</span>

            <span class="n">u2_mean_s</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">u2_var_s</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate_pair_batch</span> <span class="k">if</span> <span class="n">pair</span> <span class="k">else</span> <span class="n">interpolate_batch</span>

            <span class="k">for</span> <span class="n">locs_subset</span><span class="p">,</span> <span class="n">cats_subset</span> <span class="ow">in</span> <span class="n">for_gp</span><span class="p">:</span>
                <span class="n">u2_mean</span><span class="p">,</span> <span class="n">u2_var</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A11i</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">vals1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">,</span> <span class="n">cats1</span><span class="p">,</span> <span class="n">locs_subset</span><span class="p">,</span> <span class="n">cats_subset</span><span class="p">)</span>
                <span class="n">u2_mean</span> <span class="o">=</span> <span class="n">u2_mean</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="n">u2_var</span> <span class="o">=</span> <span class="n">u2_var</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="n">u2_mean_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u2_mean</span><span class="p">)</span>
                <span class="n">u2_var_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u2_var</span><span class="p">)</span>

            <span class="n">u2_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">u2_mean_s</span><span class="p">)</span>
            <span class="n">u2_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">u2_var_s</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">u2_mean</span><span class="p">,</span> <span class="n">u2_var</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reduce</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reduce</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span>

            <span class="k">if</span> <span class="n">subsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">subsample</span> <span class="o">&lt;=</span> <span class="n">samples</span><span class="p">,</span> <span class="s1">&#39;`subsample` may not exceed sample size&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subsample</span> <span class="o">=</span> <span class="n">samples</span>

            <span class="c1"># Thin by picking roughly equally-spaced samples.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">*</span> <span class="n">subsample</span> <span class="o">/</span> <span class="n">samples</span> <span class="o">%</span> <span class="mi">1</span>
            <span class="n">pick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">pick</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

            <span class="c1"># Make a prediction for each sample.</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tracker</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">subsample</span><span class="p">)):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">parameters</span><span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pair</span><span class="p">))</span>

            <span class="n">mm</span><span class="p">,</span> <span class="n">vv</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="o">+</span> <span class="n">vv</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m</span><span class="p">,</span> <span class="n">v</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="src.geostat.model.Model.fit" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">fit</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Trains the model using the provided location and value data by optimizing the parameters of the Gaussian Process (GP)
using the Adam optimizer. Optionally performs regularization and can handle categorical data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>locs</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing the input locations for training.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>vals</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing observed values corresponding to the <code>locs</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>cats</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing categorical data for each observation in <code>locs</code>. If provided,
the data is sorted according to <code>cats</code> to enable stratified training. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>step_size</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The learning rate for the Adam optimizer.</p>
              </div>
            </td>
            <td>
                  <code>0.01</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>iters</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The total number of iterations to run for training.</p>
              </div>
            </td>
            <td>
                  <code>100</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>reg</code></td>
            <td>
                  <code>float or None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Regularization penalty parameter. If None, no regularization is applied.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>self</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="src.geostat.model.Model" href="#src.geostat.model.Model">Model</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The model instance with updated parameters, allowing for method chaining.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Fitting a model using training data:</p>
<pre><code>from geostat import GP, Model, Parameters
from geostat.kernel import Noise
import numpy as np

# Create parameters.
p = Parameters(nugget=1.)

# Create model
kernel = Noise(nugget=p.nugget)
model = Model(GP(0, kernel))

# Fit model
locs = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]])
vals = np.array([10.0, 15.0, 20.0])
model.fit(locs, vals, step_size=0.05, iters=500)
# [iter    50 ll -63.71 time  2.72 reg  0.00 nugget  6.37]
# [iter   100 ll -32.94 time  0.25 reg  0.00 nugget 13.97]
# [iter   150 ll -23.56 time  0.25 reg  0.00 nugget 22.65]
# [iter   200 ll -19.26 time  0.25 reg  0.00 nugget 32.27]
# [iter   250 ll -16.92 time  0.25 reg  0.00 nugget 42.63]
# [iter   300 ll -15.52 time  0.24 reg  0.00 nugget 53.50]
# [iter   350 ll -14.63 time  0.24 reg  0.00 nugget 64.71]
# [iter   400 ll -14.03 time  0.24 reg  0.00 nugget 76.10]
# [iter   450 ll -13.61 time  0.25 reg  0.00 nugget 87.52]
# [iter   500 ll -13.32 time  0.24 reg  0.00 nugget 98.85]
</code></pre>
<p>Using categorical data for training:</p>
<pre><code>cats = np.array([1, 1, 2])
model.fit(locs, vals, cats=cats, step_size=0.01, iters=300)
# [iter    30 ll -12.84 time  0.25 reg  0.00 nugget 131.53]
# [iter    60 ll -12.62 time  0.15 reg  0.00 nugget 164.41]
# [iter    90 ll -12.53 time  0.16 reg  0.00 nugget 191.70]
# [iter   120 ll -12.50 time  0.16 reg  0.00 nugget 211.74]
# [iter   150 ll -12.49 time  0.15 reg  0.00 nugget 225.07]
# [iter   180 ll -12.49 time  0.16 reg  0.00 nugget 233.15]
# [iter   210 ll -12.49 time  0.15 reg  0.00 nugget 237.64]
# [iter   240 ll -12.49 time  0.15 reg  0.00 nugget 239.92]
# [iter   270 ll -12.49 time  0.15 reg  0.00 nugget 240.98]
# [iter   300 ll -12.49 time  0.15 reg  0.00 nugget 241.42]
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>fit</code> method uses the Adam optimizer to minimize the negative log-likelihood (<code>ll</code>) and any regularization 
penalties specified by <code>reg</code>.</li>
<li>During training, if <code>cats</code> are provided, data points are sorted according to <code>cats</code> to ensure grouped training.</li>
<li>The <code>verbose</code> flag determines whether training progress is printed after each iteration.</li>
<li>After training, parameter values are saved and can be accessed or updated using the model's attributes.</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>src/geostat/model.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trains the model using the provided location and value data by optimizing the parameters of the Gaussian Process (GP)</span>
<span class="sd">    using the Adam optimizer. Optionally performs regularization and can handle categorical data.</span>

<span class="sd">    Parameters:        </span>
<span class="sd">        locs (np.ndarray):</span>
<span class="sd">            A NumPy array containing the input locations for training.</span>
<span class="sd">        vals (np.ndarray):</span>
<span class="sd">            A NumPy array containing observed values corresponding to the `locs`.</span>
<span class="sd">        cats (np.ndarray, optional):</span>
<span class="sd">            A NumPy array containing categorical data for each observation in `locs`. If provided,</span>
<span class="sd">            the data is sorted according to `cats` to enable stratified training. Defaults to None.</span>
<span class="sd">        step_size (float, optional):</span>
<span class="sd">            The learning rate for the Adam optimizer.</span>
<span class="sd">        iters (int, optional):</span>
<span class="sd">            The total number of iterations to run for training.</span>
<span class="sd">        reg (float or None, optional):</span>
<span class="sd">            Regularization penalty parameter. If None, no regularization is applied.</span>

<span class="sd">    Returns:</span>
<span class="sd">        self (Model):</span>
<span class="sd">            The model instance with updated parameters, allowing for method chaining.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Fitting a model using training data:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat import GP, Model, Parameters</span>
<span class="sd">        from geostat.kernel import Noise</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        # Create parameters.</span>
<span class="sd">        p = Parameters(nugget=1.)</span>

<span class="sd">        # Create model</span>
<span class="sd">        kernel = Noise(nugget=p.nugget)</span>
<span class="sd">        model = Model(GP(0, kernel))</span>

<span class="sd">        # Fit model</span>
<span class="sd">        locs = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]])</span>
<span class="sd">        vals = np.array([10.0, 15.0, 20.0])</span>
<span class="sd">        model.fit(locs, vals, step_size=0.05, iters=500)</span>
<span class="sd">        # [iter    50 ll -63.71 time  2.72 reg  0.00 nugget  6.37]</span>
<span class="sd">        # [iter   100 ll -32.94 time  0.25 reg  0.00 nugget 13.97]</span>
<span class="sd">        # [iter   150 ll -23.56 time  0.25 reg  0.00 nugget 22.65]</span>
<span class="sd">        # [iter   200 ll -19.26 time  0.25 reg  0.00 nugget 32.27]</span>
<span class="sd">        # [iter   250 ll -16.92 time  0.25 reg  0.00 nugget 42.63]</span>
<span class="sd">        # [iter   300 ll -15.52 time  0.24 reg  0.00 nugget 53.50]</span>
<span class="sd">        # [iter   350 ll -14.63 time  0.24 reg  0.00 nugget 64.71]</span>
<span class="sd">        # [iter   400 ll -14.03 time  0.24 reg  0.00 nugget 76.10]</span>
<span class="sd">        # [iter   450 ll -13.61 time  0.25 reg  0.00 nugget 87.52]</span>
<span class="sd">        # [iter   500 ll -13.32 time  0.24 reg  0.00 nugget 98.85]</span>
<span class="sd">        ```</span>

<span class="sd">        Using categorical data for training:</span>

<span class="sd">        ```</span>
<span class="sd">        cats = np.array([1, 1, 2])</span>
<span class="sd">        model.fit(locs, vals, cats=cats, step_size=0.01, iters=300)</span>
<span class="sd">        # [iter    30 ll -12.84 time  0.25 reg  0.00 nugget 131.53]</span>
<span class="sd">        # [iter    60 ll -12.62 time  0.15 reg  0.00 nugget 164.41]</span>
<span class="sd">        # [iter    90 ll -12.53 time  0.16 reg  0.00 nugget 191.70]</span>
<span class="sd">        # [iter   120 ll -12.50 time  0.16 reg  0.00 nugget 211.74]</span>
<span class="sd">        # [iter   150 ll -12.49 time  0.15 reg  0.00 nugget 225.07]</span>
<span class="sd">        # [iter   180 ll -12.49 time  0.16 reg  0.00 nugget 233.15]</span>
<span class="sd">        # [iter   210 ll -12.49 time  0.15 reg  0.00 nugget 237.64]</span>
<span class="sd">        # [iter   240 ll -12.49 time  0.15 reg  0.00 nugget 239.92]</span>
<span class="sd">        # [iter   270 ll -12.49 time  0.15 reg  0.00 nugget 240.98]</span>
<span class="sd">        # [iter   300 ll -12.49 time  0.15 reg  0.00 nugget 241.42]</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `fit` method uses the Adam optimizer to minimize the negative log-likelihood (`ll`) and any regularization </span>
<span class="sd">        penalties specified by `reg`.</span>
<span class="sd">        - During training, if `cats` are provided, data points are sorted according to `cats` to ensure grouped training.</span>
<span class="sd">        - The `verbose` flag determines whether training progress is printed after each iteration.</span>
<span class="sd">        - After training, parameter values are saved and can be accessed or updated using the model&#39;s attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Collect parameters and create TF parameters.</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span>

    <span class="c1"># Permute datapoints if cats is given.</span>
    <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
        <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Data dict.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;warplocs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs</span><span class="p">),</span>
        <span class="s1">&#39;vals&#39;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="s1">&#39;cats&#39;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">step_size</span><span class="p">)</span>

    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Iteration count.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">iters</span> <span class="o">/</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">ll</span><span class="p">,</span> <span class="n">reg_penalty</span> <span class="o">=</span> <span class="n">gp_train_step</span><span class="p">(</span>
                <span class="n">optimizer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">time_elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
              <span class="nb">dict</span><span class="p">(</span><span class="nb">iter</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">ll</span><span class="o">=</span><span class="n">ll</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time_elapsed</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="n">reg_penalty</span><span class="p">)</span> <span class="o">|</span>
              <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">surface</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()})</span>

    <span class="c1"># Save parameter values.</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">p</span><span class="o">.</span><span class="n">update_value</span><span class="p">()</span>

    <span class="c1"># Restore order if things were permuted.</span>
    <span class="k">if</span> <span class="n">perm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">revperm</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cats</span> <span class="o">=</span> <span class="n">cats</span>

    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.geostat.model.Model.generate" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">generate</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">cats</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Generates synthetic data values from the Gaussian Process (GP) model based on the provided location data.
This method simulates values based on the GP's covariance structure, allowing for random sample generation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>locs</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing the input locations for which to generate synthetic values.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>cats</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing categorical data corresponding to <code>locs</code>. If provided, data points 
are permuted according to <code>cats</code> for stratified generation. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>self</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="src.geostat.model.Model" href="#src.geostat.model.Model">Model</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The model instance with generated values stored in <code>self.vals</code> and corresponding locations stored 
in <code>self.locs</code>. This enables method chaining.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Generating synthetic values for a set of locations:</p>
<pre><code>from geostat import GP, Model, Parameters
from geostat.kernel import Noise
import numpy as np

# Create parameters.
p = Parameters(nugget=1.)

# Create model
kernel = Noise(nugget=p.nugget)
model = Model(GP(0, kernel))

# Generate values based on locs
locs = np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])
model.generate(locs)
generated_vals = model.vals  # Access the generated values
print(generated_vals)
# [0.45151083 1.23276189 0.3822659 ] (Values are non-deterministic)
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Conditional generation is currently not supported, and this method will raise an assertion error if 
<code>self.locs</code> and <code>self.vals</code> are already defined.</li>
<li>Generation from a distribution is not yet supported, and an assertion error will be raised if 
<code>self.parameter_sample_size</code> is not <code>None</code>.</li>
<li>If <code>cats</code> are provided, the data is permuted according to <code>cats</code> for stratified generation, and 
the original order is restored before returning.</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>src/geostat/model.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">cats</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates synthetic data values from the Gaussian Process (GP) model based on the provided location data.</span>
<span class="sd">    This method simulates values based on the GP&#39;s covariance structure, allowing for random sample generation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        locs (np.ndarray):</span>
<span class="sd">            A NumPy array containing the input locations for which to generate synthetic values.</span>
<span class="sd">        cats (np.ndarray, optional):</span>
<span class="sd">            A NumPy array containing categorical data corresponding to `locs`. If provided, data points </span>
<span class="sd">            are permuted according to `cats` for stratified generation. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        self (Model):</span>
<span class="sd">            The model instance with generated values stored in `self.vals` and corresponding locations stored </span>
<span class="sd">            in `self.locs`. This enables method chaining.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Generating synthetic values for a set of locations:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat import GP, Model, Parameters</span>
<span class="sd">        from geostat.kernel import Noise</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        # Create parameters.</span>
<span class="sd">        p = Parameters(nugget=1.)</span>

<span class="sd">        # Create model</span>
<span class="sd">        kernel = Noise(nugget=p.nugget)</span>
<span class="sd">        model = Model(GP(0, kernel))</span>

<span class="sd">        # Generate values based on locs</span>
<span class="sd">        locs = np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])</span>
<span class="sd">        model.generate(locs)</span>
<span class="sd">        generated_vals = model.vals  # Access the generated values</span>
<span class="sd">        print(generated_vals)</span>
<span class="sd">        # [0.45151083 1.23276189 0.3822659 ] (Values are non-deterministic)</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Conditional generation is currently not supported, and this method will raise an assertion error if </span>
<span class="sd">        `self.locs` and `self.vals` are already defined.</span>
<span class="sd">        - Generation from a distribution is not yet supported, and an assertion error will be raised if </span>
<span class="sd">        `self.parameter_sample_size` is not `None`.</span>
<span class="sd">        - If `cats` are provided, the data is permuted according to `cats` for stratified generation, and </span>
<span class="sd">        the original order is restored before returning.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Conditional generation not yet supported&#39;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Generation from a distribution not yet supported&#39;</span>

    <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>

    <span class="c1"># Permute datapoints if cats is given.</span>
    <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
        <span class="n">locs</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">({}),</span>
        <span class="kc">None</span> <span class="k">if</span> <span class="n">cats</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

    <span class="n">vals</span> <span class="o">=</span> <span class="n">MVN</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">S</span><span class="p">))</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="c1"># Restore order if things were permuted.</span>
    <span class="k">if</span> <span class="n">perm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">locs</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">revperm</span><span class="p">],</span> <span class="n">cats</span><span class="p">[</span><span class="n">revperm</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cats</span> <span class="o">=</span> <span class="n">cats</span>

    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.geostat.model.Model.predict" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">predict</span><span class="p">(</span><span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">subsample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduce</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tracker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Performs Gaussian Process (GP) predictions of the mean and variance for the given location data.
Supports batch predictions for large datasets and can handle categorical data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>locs2</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing the input locations for which predictions are to be made.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>cats2</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A NumPy array containing categorical data for the prediction locations (<code>locs2</code>). If provided,
the data points will be permuted according to <code>cats2</code>. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>subsample</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifies the number of parameter samples to be used for prediction when <code>parameter_sample_size</code> is set.
Only valid if parameters are sampled. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>reduce</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifies the reduction method ('mean' or 'median') to aggregate predictions from multiple parameter samples.
Only valid if parameters are sampled. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>tracker</code></td>
            <td>
                  <code><span title="typing.Callable">Callable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A tracking function for monitoring progress when making predictions across multiple samples. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>pair</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, performs pairwise predictions of mean and variance for each pair of input points in <code>locs2</code>.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>m</code></td>            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The predicted mean values for the input locations.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>v</code></td>            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The predicted variances for the input locations.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Making predictions for a set of locations:</p>
<pre><code>from geostat import GP, Model, Parameters
from geostat.kernel import SquaredExponential
import numpy as np

# Create parameters.
p = Parameters(sill=1.0, range=2.0)

# Create model
kernel = SquaredExponential(sill=p.sill, range=p.range)
model = Model(GP(0, kernel))

# Fit model
locs = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]])
vals = np.array([10.0, 15.0, 20.0])
model.fit(locs, vals, step_size=0.05, iters=500)
# [iter    50 ll -40.27 time  2.29 reg  0.00 sill  6.35 range  1.96]
# [iter   100 ll -21.79 time  0.40 reg  0.00 sill 13.84 range  2.18]
# [iter   150 ll -16.17 time  0.39 reg  0.00 sill 22.31 range  2.44]
# [iter   200 ll -13.55 time  0.39 reg  0.00 sill 31.75 range  2.76]
# [iter   250 ll -12.08 time  0.38 reg  0.00 sill 42.08 range  3.12]
# [iter   300 ll -11.14 time  0.38 reg  0.00 sill 53.29 range  3.48]
# [iter   350 ll -10.50 time  0.38 reg  0.00 sill 65.36 range  3.85]
# [iter   400 ll -10.05 time  0.39 reg  0.00 sill 78.29 range  4.22]
# [iter   450 ll -9.70 time  0.39 reg  0.00 sill 92.07 range  4.59]
# [iter   500 ll -9.43 time  0.39 reg  0.00 sill 106.70 range  4.95]

# Run predictions
locs2 = np.array([[1.5, 1.5], [2.5, 4.0]])
mean, variance = model.predict(locs2)
print(mean)
# [ 9.89839798 18.77077269]
print(variance)
# [2.1572128  0.54444738]
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>If <code>subsample</code> is specified, it should be used only when <code>parameter_sample_size</code> is defined.</li>
<li>The <code>reduce</code> parameter allows aggregation of predictions, but it's valid only with sampled parameters.</li>
<li>The method supports pairwise predictions by setting <code>pair=True</code>, which is useful for predicting 
the covariance between two sets of locations.</li>
<li>The internal <code>interpolate_batch</code> and <code>interpolate_pair_batch</code> functions handle the prediction computations
in a batched manner to support large datasets efficiently.</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>src/geostat/model.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">subsample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduce</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tracker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs Gaussian Process (GP) predictions of the mean and variance for the given location data.</span>
<span class="sd">    Supports batch predictions for large datasets and can handle categorical data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        locs2 (np.ndarray):</span>
<span class="sd">            A NumPy array containing the input locations for which predictions are to be made.</span>
<span class="sd">        cats2 (np.ndarray, optional):</span>
<span class="sd">            A NumPy array containing categorical data for the prediction locations (`locs2`). If provided,</span>
<span class="sd">            the data points will be permuted according to `cats2`. Default is None.</span>
<span class="sd">        subsample (int, optional):</span>
<span class="sd">            Specifies the number of parameter samples to be used for prediction when `parameter_sample_size` is set.</span>
<span class="sd">            Only valid if parameters are sampled. Default is None.</span>
<span class="sd">        reduce (str, optional):</span>
<span class="sd">            Specifies the reduction method (&#39;mean&#39; or &#39;median&#39;) to aggregate predictions from multiple parameter samples.</span>
<span class="sd">            Only valid if parameters are sampled. Default is None.</span>
<span class="sd">        tracker (Callable, optional):</span>
<span class="sd">            A tracking function for monitoring progress when making predictions across multiple samples. Default is None.</span>
<span class="sd">        pair (bool, optional):</span>
<span class="sd">            If True, performs pairwise predictions of mean and variance for each pair of input points in `locs2`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        m (np.ndarray):</span>
<span class="sd">            The predicted mean values for the input locations.</span>
<span class="sd">        v (np.ndarray):</span>
<span class="sd">            The predicted variances for the input locations.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Making predictions for a set of locations:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat import GP, Model, Parameters</span>
<span class="sd">        from geostat.kernel import SquaredExponential</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        # Create parameters.</span>
<span class="sd">        p = Parameters(sill=1.0, range=2.0)</span>

<span class="sd">        # Create model</span>
<span class="sd">        kernel = SquaredExponential(sill=p.sill, range=p.range)</span>
<span class="sd">        model = Model(GP(0, kernel))</span>

<span class="sd">        # Fit model</span>
<span class="sd">        locs = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]])</span>
<span class="sd">        vals = np.array([10.0, 15.0, 20.0])</span>
<span class="sd">        model.fit(locs, vals, step_size=0.05, iters=500)</span>
<span class="sd">        # [iter    50 ll -40.27 time  2.29 reg  0.00 sill  6.35 range  1.96]</span>
<span class="sd">        # [iter   100 ll -21.79 time  0.40 reg  0.00 sill 13.84 range  2.18]</span>
<span class="sd">        # [iter   150 ll -16.17 time  0.39 reg  0.00 sill 22.31 range  2.44]</span>
<span class="sd">        # [iter   200 ll -13.55 time  0.39 reg  0.00 sill 31.75 range  2.76]</span>
<span class="sd">        # [iter   250 ll -12.08 time  0.38 reg  0.00 sill 42.08 range  3.12]</span>
<span class="sd">        # [iter   300 ll -11.14 time  0.38 reg  0.00 sill 53.29 range  3.48]</span>
<span class="sd">        # [iter   350 ll -10.50 time  0.38 reg  0.00 sill 65.36 range  3.85]</span>
<span class="sd">        # [iter   400 ll -10.05 time  0.39 reg  0.00 sill 78.29 range  4.22]</span>
<span class="sd">        # [iter   450 ll -9.70 time  0.39 reg  0.00 sill 92.07 range  4.59]</span>
<span class="sd">        # [iter   500 ll -9.43 time  0.39 reg  0.00 sill 106.70 range  4.95]</span>

<span class="sd">        # Run predictions</span>
<span class="sd">        locs2 = np.array([[1.5, 1.5], [2.5, 4.0]])</span>
<span class="sd">        mean, variance = model.predict(locs2)</span>
<span class="sd">        print(mean)</span>
<span class="sd">        # [ 9.89839798 18.77077269]</span>
<span class="sd">        print(variance)</span>
<span class="sd">        # [2.1572128  0.54444738]</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - If `subsample` is specified, it should be used only when `parameter_sample_size` is defined.</span>
<span class="sd">        - The `reduce` parameter allows aggregation of predictions, but it&#39;s valid only with sampled parameters.</span>
<span class="sd">        - The method supports pairwise predictions by setting `pair=True`, which is useful for predicting </span>
<span class="sd">        the covariance between two sets of locations.</span>
<span class="sd">        - The internal `interpolate_batch` and `interpolate_pair_batch` functions handle the prediction computations</span>
<span class="sd">        in a batched manner to support large datasets efficiently.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">subsample</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
        <span class="s1">&#39;`subsample` is only valid with sampled parameters&#39;</span>

    <span class="k">assert</span> <span class="n">reduce</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
        <span class="s1">&#39;`reduce` is only valid with sampled parameters&#39;</span>

    <span class="k">assert</span> <span class="n">subsample</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">reduce</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> \
        <span class="s1">&#39;`subsample` and `reduce` cannot both be given&#39;</span>

    <span class="k">if</span> <span class="n">tracker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tracker</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">locs2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;Mismatch in location dimensions&#39;</span>
    <span class="k">if</span> <span class="n">cats2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">cats2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">locs2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;Mismatched shapes in cats and locs&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cats2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">locs2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpolate_batch</span><span class="p">(</span><span class="n">A11i</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">vals1diff</span><span class="p">,</span> <span class="n">cats1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inputs:</span>
<span class="sd">          locs1.shape = [N1, K]</span>
<span class="sd">          vals1diff.shape = [N1]</span>
<span class="sd">          cats1.shape = [N1]</span>
<span class="sd">          locs2.shape = [N2, K]</span>
<span class="sd">          cats2.shape = [N2]</span>

<span class="sd">        Outputs:</span>
<span class="sd">          u2_mean.shape = [N2]</span>
<span class="sd">          u2_var.shape = [N2]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs1</span><span class="p">)</span> <span class="c1"># Number of measurements.</span>

        <span class="c1"># Permute datapoints if cats is given.</span>
        <span class="k">if</span> <span class="n">cats2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats2</span><span class="p">)</span>
            <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span> <span class="o">=</span> <span class="n">locs2</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats2</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
            <span class="n">locs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">({})</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">A12</span> <span class="o">=</span> <span class="n">gp_covariance2</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">N1</span><span class="p">)</span>

        <span class="n">m2</span><span class="p">,</span> <span class="n">A22</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

        <span class="c1"># Restore order if things were permuted.</span>
        <span class="k">if</span> <span class="n">cats2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">revperm</span><span class="p">)</span>
            <span class="n">A12</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">revperm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">A22</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">A22</span><span class="p">,</span> <span class="n">revperm</span><span class="p">),</span> <span class="n">revperm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">u2_mean</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,a-&gt;b&#39;</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,b-&gt;a&#39;</span><span class="p">,</span> <span class="n">A11i</span><span class="p">,</span> <span class="n">vals1diff</span><span class="p">))</span>
        <span class="n">u2_var</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">diag_part</span><span class="p">(</span><span class="n">A22</span><span class="p">)</span> <span class="o">-</span>  <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,ab-&gt;b&#39;</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A11i</span><span class="p">,</span> <span class="n">A12</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">u2_mean</span><span class="p">,</span> <span class="n">u2_var</span>

    <span class="k">def</span> <span class="nf">interpolate_pair_batch</span><span class="p">(</span><span class="n">A11i</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">vals1diff</span><span class="p">,</span> <span class="n">cats1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inputs:</span>
<span class="sd">          locs1.shape = [N1, K]</span>
<span class="sd">          vals1diff.shape = [N1]</span>
<span class="sd">          cats1.shape = [N1]</span>
<span class="sd">          locs2.shape = [N2, 2, K]</span>
<span class="sd">          cats2.shape = [N2]</span>

<span class="sd">        Outputs:</span>
<span class="sd">          u2_mean.shape = [N2, 2]</span>
<span class="sd">          u2_var.shape = [N2, 2, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs1</span><span class="p">)</span> <span class="c1"># Number of measurements.</span>
        <span class="n">N2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs2</span><span class="p">)</span> <span class="c1"># Number of prediction pairs.</span>

        <span class="c1"># Permute datapoints if cats is given.</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats2</span><span class="p">)</span>
        <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span> <span class="o">=</span> <span class="n">locs2</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats2</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>

        <span class="c1"># Warp locs2.</span>
        <span class="n">locs2_shape</span> <span class="o">=</span> <span class="n">locs2</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">locs2</span> <span class="o">=</span> <span class="n">locs2</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">locs2_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>  <span class="c1"># Shape into matrix.</span>
        <span class="n">locs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">({})</span>
        <span class="n">locs2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">locs2</span><span class="p">,</span> <span class="n">locs2_shape</span><span class="p">)</span>  <span class="c1"># Revert shape.</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">A12</span> <span class="o">=</span> <span class="n">gp_covariance2</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">N1</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">A13</span> <span class="o">=</span> <span class="n">gp_covariance2</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">N1</span><span class="p">)</span>

        <span class="n">m2</span><span class="p">,</span> <span class="n">A22</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

        <span class="n">m3</span><span class="p">,</span> <span class="n">A33</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">A23</span> <span class="o">=</span> <span class="n">gp_covariance2</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">N2</span><span class="p">)</span>

        <span class="c1"># Reassemble into more useful shapes.</span>

        <span class="n">A12</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">A12</span><span class="p">,</span> <span class="n">A13</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [N1, N2, 2]</span>

        <span class="n">m2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">m2</span><span class="p">,</span> <span class="n">m3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [N2, 2]</span>

        <span class="n">A22</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">diag_part</span><span class="p">(</span><span class="n">A22</span><span class="p">)</span>
        <span class="n">A33</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">diag_part</span><span class="p">(</span><span class="n">A33</span><span class="p">)</span>
        <span class="n">A23</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">diag_part</span><span class="p">(</span><span class="n">A23</span><span class="p">)</span>
        <span class="n">A22</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">A22</span><span class="p">,</span> <span class="n">A23</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">A23</span><span class="p">,</span> <span class="n">A33</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># [N2, 2, 2]</span>

        <span class="c1"># Restore order if things were permuted.</span>
        <span class="n">revperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">revperm</span><span class="p">)</span>
        <span class="n">A12</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">revperm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A22</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">A22</span><span class="p">,</span> <span class="n">revperm</span><span class="p">)</span>

        <span class="n">u2_mean</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abc,a-&gt;bc&#39;</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,b-&gt;a&#39;</span><span class="p">,</span> <span class="n">A11i</span><span class="p">,</span> <span class="n">vals1diff</span><span class="p">))</span>
        <span class="n">u2_var</span> <span class="o">=</span> <span class="n">A22</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abc,abd-&gt;bcd&#39;</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ae,ebd-&gt;abd&#39;</span><span class="p">,</span> <span class="n">A11i</span><span class="p">,</span> <span class="n">A12</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">u2_mean</span><span class="p">,</span> <span class="n">u2_var</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">vals1</span><span class="p">,</span> <span class="n">cats1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Interpolate in batches.</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">locs1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="n">for_gp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs2</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">batch_size</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">locs2</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">],</span> <span class="n">cats2</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="n">for_gp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>

        <span class="c1"># Permute datapoints if cats is given.</span>
        <span class="k">if</span> <span class="n">cats1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cats1</span><span class="p">)</span>
            <span class="n">locs1</span><span class="p">,</span> <span class="n">vals1</span><span class="p">,</span> <span class="n">cats1</span> <span class="o">=</span> <span class="n">locs1</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">vals1</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">cats1</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>

        <span class="n">locs1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">locs1</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">({})</span>

        <span class="n">m1</span><span class="p">,</span> <span class="n">A11</span> <span class="o">=</span> <span class="n">gp_covariance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">cats1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

        <span class="n">A11i</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A11</span><span class="p">)</span>

        <span class="n">u2_mean_s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">u2_var_s</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate_pair_batch</span> <span class="k">if</span> <span class="n">pair</span> <span class="k">else</span> <span class="n">interpolate_batch</span>

        <span class="k">for</span> <span class="n">locs_subset</span><span class="p">,</span> <span class="n">cats_subset</span> <span class="ow">in</span> <span class="n">for_gp</span><span class="p">:</span>
            <span class="n">u2_mean</span><span class="p">,</span> <span class="n">u2_var</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A11i</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">vals1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">,</span> <span class="n">cats1</span><span class="p">,</span> <span class="n">locs_subset</span><span class="p">,</span> <span class="n">cats_subset</span><span class="p">)</span>
            <span class="n">u2_mean</span> <span class="o">=</span> <span class="n">u2_mean</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">u2_var</span> <span class="o">=</span> <span class="n">u2_var</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">u2_mean_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u2_mean</span><span class="p">)</span>
            <span class="n">u2_var_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u2_var</span><span class="p">)</span>

        <span class="n">u2_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">u2_mean_s</span><span class="p">)</span>
        <span class="n">u2_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">u2_var_s</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">u2_mean</span><span class="p">,</span> <span class="n">u2_var</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reduce</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reduce</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_sample_size</span>

        <span class="k">if</span> <span class="n">subsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">subsample</span> <span class="o">&lt;=</span> <span class="n">samples</span><span class="p">,</span> <span class="s1">&#39;`subsample` may not exceed sample size&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subsample</span> <span class="o">=</span> <span class="n">samples</span>

        <span class="c1"># Thin by picking roughly equally-spaced samples.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">*</span> <span class="n">subsample</span> <span class="o">/</span> <span class="n">samples</span> <span class="o">%</span> <span class="mi">1</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">pick</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="c1"># Make a prediction for each sample.</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tracker</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">subsample</span><span class="p">)):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nest</span><span class="o">.</span><span class="n">map_structure</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">parameters</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cats</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">cats2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pair</span><span class="p">))</span>

        <span class="n">mm</span><span class="p">,</span> <span class="n">vv</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="o">+</span> <span class="n">vv</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">m</span><span class="p">,</span> <span class="n">v</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.geostat.model.Model.set" class="doc doc-heading">
            <code class="highlight language-python"><span class="nb">set</span><span class="p">(</span><span class="o">**</span><span class="n">values</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Sets the values of the model's parameters based on the provided keyword arguments.
Each parameter specified must exist in the model; otherwise, a <code>ValueError</code> is raised.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>values</code></td>
            <td>
                  <code>keyword arguments</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of parameter names and their corresponding values that should be 
set in the model. Each key corresponds to a parameter name, and the value is 
the value to be assigned to that parameter.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>self</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="src.geostat.model.Model" href="#src.geostat.model.Model">Model</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The model instance with updated parameter values, allowing for method chaining.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If a provided parameter name does not exist in the model's parameters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Update parameter value using <code>set</code>:</p>
<pre><code>from geostat import GP, Model, Parameters
from geostat.kernel import Noise

# Create parameters.
p = Parameters(nugget=1.)

# Create model
kernel = Noise(nugget=p.nugget)
model = Model(GP(0, kernel))

# Update parameters
model.set(nugget=0.5)
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>set</code> method retrieves the current parameters using <code>gather_vars</code> and updates 
their values. The associated TensorFlow variables are also recreated.</li>
<li>This method is useful for dynamically updating the model's parameters after initialization.</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>src/geostat/model.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">values</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets the values of the model&#39;s parameters based on the provided keyword arguments.</span>
<span class="sd">    Each parameter specified must exist in the model; otherwise, a `ValueError` is raised.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        values (keyword arguments):</span>
<span class="sd">            A dictionary of parameter names and their corresponding values that should be </span>
<span class="sd">            set in the model. Each key corresponds to a parameter name, and the value is </span>
<span class="sd">            the value to be assigned to that parameter.</span>

<span class="sd">    Returns:</span>
<span class="sd">        self (Model):</span>
<span class="sd">            The model instance with updated parameter values, allowing for method chaining.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError:</span>
<span class="sd">            If a provided parameter name does not exist in the model&#39;s parameters.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Update parameter value using `set`:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat import GP, Model, Parameters</span>
<span class="sd">        from geostat.kernel import Noise</span>

<span class="sd">        # Create parameters.</span>
<span class="sd">        p = Parameters(nugget=1.)</span>

<span class="sd">        # Create model</span>
<span class="sd">        kernel = Noise(nugget=p.nugget)</span>
<span class="sd">        model = Model(GP(0, kernel))</span>

<span class="sd">        # Update parameters</span>
<span class="sd">        model.set(nugget=0.5)</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `set` method retrieves the current parameters using `gather_vars` and updates </span>
<span class="sd">        their values. The associated TensorFlow variables are also recreated.</span>
<span class="sd">        - This method is useful for dynamically updating the model&#39;s parameters after initialization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
            <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">create_tf_variable</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not a parameter&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />


<div class="doc doc-object doc-module">



<h2 id="src.geostat.kernel" class="doc doc-heading">
            <code>src.geostat.kernel</code>


</h2>

    <div class="doc doc-contents first">



  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Constant" class="doc doc-heading">
            <code>Constant</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Constant kernel class for Gaussian Processes (GPs).</p>
<p>The <code>Constant</code> class defines a simple kernel that produces a constant covariance value across
all pairs of input locations. This kernel is typically used to represent a baseline level of
variance (sill) in the GP model.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>sill</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The constant value representing the sill (baseline variance) of the kernel.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>Constant</code> kernel:</p>
<pre><code>from geostat import Parameters
from geostat.kernel import Constant
import numpy as np

# Create parameters.
p = Parameters(sill=2.0)

# Create a Constant kernel with a sill value of 2.0 and call it
locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
constant_kernel = Constant(sill=p.sill)
covariance_matrix = constant_kernel({'locs1': locs1, 'locs2': locs2, 'sill': 2.0})
print(covariance_matrix)
# tf.Tensor(
# [[2. 2. 2.]
#  [2. 2. 2.]
#  [2. 2. 2.]], shape=(3, 3), dtype=float32)
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method returns the constant value specified by <code>sill</code> for all pairs of input locations.</li>
<li>The <code>vars</code> method returns the parameter dictionary for <code>sill</code> using the <code>ppp</code> function.</li>
<li>The <code>Constant</code> kernel is useful when you want to add a fixed variance component to your GP model.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Constant</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constant kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `Constant` class defines a simple kernel that produces a constant covariance value across</span>
<span class="sd">    all pairs of input locations. This kernel is typically used to represent a baseline level of</span>
<span class="sd">    variance (sill) in the GP model.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        sill (float or tf.Variable):</span>
<span class="sd">            The constant value representing the sill (baseline variance) of the kernel.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `Constant` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat import Parameters</span>
<span class="sd">        from geostat.kernel import Constant</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        # Create parameters.</span>
<span class="sd">        p = Parameters(sill=2.0)</span>

<span class="sd">        # Create a Constant kernel with a sill value of 2.0 and call it</span>
<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        constant_kernel = Constant(sill=p.sill)</span>
<span class="sd">        covariance_matrix = constant_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;sill&#39;: 2.0})</span>
<span class="sd">        print(covariance_matrix)</span>
<span class="sd">        # tf.Tensor(</span>
<span class="sd">        # [[2. 2. 2.]</span>
<span class="sd">        #  [2. 2. 2.]</span>
<span class="sd">        #  [2. 2. 2.]], shape=(3, 3), dtype=float32)</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method returns the constant value specified by `sill` for all pairs of input locations.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for `sill` using the `ppp` function.</span>
<span class="sd">        - The `Constant` kernel is useful when you want to add a fixed variance component to your GP model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sill</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sill</span><span class="o">=</span><span class="n">sill</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Delta" class="doc doc-heading">
            <code>Delta</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Delta kernel class for Gaussian Processes (GPs).</p>
<p>The <code>Delta</code> class defines a kernel that models a Dirac delta function effect, where covariance
is non-zero only when the inputs are identical. This kernel is useful for capturing exact matches
between input points, weighted by the specified <code>sill</code> parameter.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>sill</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The variance (sill) representing the weight of the delta function. This value is applied 
when input locations match exactly.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>axes</code></td>
            <td>
                  <code>list or None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of axes over which to apply the delta function. If not specified, the delta function 
is applied across all axes.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>Delta</code> kernel:</p>
<pre><code>from geostat.kernel import Delta

# Create a Delta kernel with a sill of 1.0, applied across all axes
delta_kernel = Delta(sill=1.0)

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = delta_kernel({'locs1': locs1, 'locs2': locs2, 'sill': 1.0})
</code></pre>
<p>Using the <code>Delta</code> kernel with specified axes:</p>
<pre><code>delta_kernel_axes = Delta(sill=1.0, axes=[0])
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes a covariance matrix using a delta function, returning <code>sill</code> when the 
    squared distances are zero along the specified axes, and 0 otherwise.</li>
<li>The <code>vars</code> method returns the parameter dictionary for <code>sill</code> using the <code>ppp</code> function.</li>
<li>The <code>Delta</code> kernel is useful for modeling processes that exhibit exact matches or sharp changes 
    in covariance when inputs coincide, making it ideal for capturing discrete effects.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Delta</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Delta kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `Delta` class defines a kernel that models a Dirac delta function effect, where covariance</span>
<span class="sd">    is non-zero only when the inputs are identical. This kernel is useful for capturing exact matches</span>
<span class="sd">    between input points, weighted by the specified `sill` parameter.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        sill (float or tf.Variable):</span>
<span class="sd">            The variance (sill) representing the weight of the delta function. This value is applied </span>
<span class="sd">            when input locations match exactly.</span>
<span class="sd">        axes (list or None, optional):</span>
<span class="sd">            A list of axes over which to apply the delta function. If not specified, the delta function </span>
<span class="sd">            is applied across all axes.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `Delta` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import Delta</span>

<span class="sd">        # Create a Delta kernel with a sill of 1.0, applied across all axes</span>
<span class="sd">        delta_kernel = Delta(sill=1.0)</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = delta_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;sill&#39;: 1.0})</span>
<span class="sd">        ```</span>

<span class="sd">        Using the `Delta` kernel with specified axes:</span>

<span class="sd">        ```</span>
<span class="sd">        delta_kernel_axes = Delta(sill=1.0, axes=[0])</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes a covariance matrix using a delta function, returning `sill` when the </span>
<span class="sd">            squared distances are zero along the specified axes, and 0 otherwise.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for `sill` using the `ppp` function.</span>
<span class="sd">        - The `Delta` kernel is useful for modeling processes that exhibit exact matches or sharp changes </span>
<span class="sd">            in covariance when inputs coincide, making it ideal for capturing discrete effects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sill</span><span class="o">=</span><span class="n">sill</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">pa_d2</span><span class="o">=</span><span class="s1">&#39;per_axis_dist2&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;pa_d2&#39;</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">maxlength</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abc,c-&gt;ab&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;pa_d2&#39;</span><span class="p">],</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;pa_d2&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.GammaExponential" class="doc doc-heading">
            <code>GammaExponential</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>GammaExponential kernel class for Gaussian Processes (GPs).</p>
<p>The <code>GammaExponential</code> class defines a kernel that generalizes the Squared Exponential kernel by introducing
a gamma parameter, allowing for greater flexibility in modeling covariance structures. It can capture processes
with varying degrees of smoothness, depending on the value of <code>gamma</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>range</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The length scale parameter that controls how quickly the covariance decreases with distance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>sill</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The variance (sill) of the kernel, representing the maximum covariance value.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>gamma</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The smoothness parameter. A value of 1 results in the standard exponential kernel, while a value of 2 
recovers the Squared Exponential kernel. Values between 0 and 2 adjust the smoothness of the kernel.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>scale</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional scale parameter that can be used to modify the metric. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>metric</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional metric used for distance calculation. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>GammaExponential</code> kernel:</p>
<pre><code>from geostat.kernel import GammaExponential

# Create a GammaExponential kernel with sill=1.0, range=2.0, and gamma=1.5
gamma_exp_kernel = GammaExponential(range=2.0, sill=1.0, gamma=1.5)

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = gamma_exp_kernel({'locs1': locs1, 'locs2': locs2, 'sill': 1.0, 'range': 2.0, 'gamma': 1.5})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix using the gamma-exponential formula:
    <span class="arithmatex">\( C(x, x') = \text{sill} \cdot \exp\left(-\left(\frac{d^2}{\text{range}^2}\right)^{\text{gamma} / 2}\right) \)</span>,
    where <span class="arithmatex">\(d^2\)</span> is the squared distance between <code>locs1</code> and <code>locs2</code>.</li>
<li>The <code>vars</code> method returns the parameter dictionary for <code>sill</code>, <code>range</code>, and <code>gamma</code> using the <code>ppp</code> and <code>bpp</code> functions.</li>
<li>The <code>GammaExponential</code> kernel provides a more flexible covariance structure than the Squared Exponential kernel,
    allowing for varying degrees of smoothness.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">GammaExponential</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GammaExponential kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `GammaExponential` class defines a kernel that generalizes the Squared Exponential kernel by introducing</span>
<span class="sd">    a gamma parameter, allowing for greater flexibility in modeling covariance structures. It can capture processes</span>
<span class="sd">    with varying degrees of smoothness, depending on the value of `gamma`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        range (float or tf.Variable):</span>
<span class="sd">            The length scale parameter that controls how quickly the covariance decreases with distance.</span>
<span class="sd">        sill (float or tf.Variable):</span>
<span class="sd">            The variance (sill) of the kernel, representing the maximum covariance value.</span>
<span class="sd">        gamma (float or tf.Variable):</span>
<span class="sd">            The smoothness parameter. A value of 1 results in the standard exponential kernel, while a value of 2 </span>
<span class="sd">            recovers the Squared Exponential kernel. Values between 0 and 2 adjust the smoothness of the kernel.</span>
<span class="sd">        scale (optional):</span>
<span class="sd">            An optional scale parameter that can be used to modify the metric. Default is None.</span>
<span class="sd">        metric (optional):</span>
<span class="sd">            An optional metric used for distance calculation. Default is None.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `GammaExponential` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import GammaExponential</span>

<span class="sd">        # Create a GammaExponential kernel with sill=1.0, range=2.0, and gamma=1.5</span>
<span class="sd">        gamma_exp_kernel = GammaExponential(range=2.0, sill=1.0, gamma=1.5)</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = gamma_exp_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;sill&#39;: 1.0, &#39;range&#39;: 2.0, &#39;gamma&#39;: 1.5})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix using the gamma-exponential formula:</span>
<span class="sd">            \\( C(x, x&#39;) = \\text{sill} \cdot \exp\left(-\left(\\frac{d^2}{\\text{range}^2}\\right)^{\\text{gamma} / 2}\\right) \\),</span>
<span class="sd">            where \\(d^2\\) is the squared distance between `locs1` and `locs2`.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for `sill`, `range`, and `gamma` using the `ppp` and `bpp` functions.</span>
<span class="sd">        - The `GammaExponential` kernel provides a more flexible covariance structure than the Squared Exponential kernel,</span>
<span class="sd">            allowing for varying degrees of smoothness.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sill</span><span class="o">=</span><span class="n">sill</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">autoinputs</span> <span class="o">=</span> <span class="n">scale_to_metric</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d2</span><span class="o">=</span><span class="n">autoinputs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">bpp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">gamma_exp</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;d2&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]),</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.IntExponential" class="doc doc-heading">
            <code>IntExponential</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Integrated Exponential (IntExponential) kernel class for Gaussian Processes (GPs).</p>
<p>The <code>IntExponential</code> class defines a kernel that integrates the Exponential kernel
along a specified axis. This kernel is useful for modeling processes with exponential 
decay along one dimension, starting from a given point.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>axis</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axis along which the integration is performed (e.g., 0 for x-axis, 1 for y-axis).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>start</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The starting point of the integration along the specified axis.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>range</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The length scale parameter that controls how quickly the covariance decreases with distance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using an <code>IntExponential</code> kernel:</p>
<pre><code>from geostat.kernel import IntExponential

# Create an IntExponential kernel integrating along the x-axis starting from 0.0 with a range of 2.0
int_exp_kernel = IntExponential(axis=0, start=0.0, range=2.0)

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = int_exp_kernel({'locs1': locs1, 'locs2': locs2, 'range': 2.0})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the integrated exponential covariance matrix based on the 
    specified axis, starting point, and range.</li>
<li>The <code>vars</code> method returns the parameter dictionary for <code>range</code> using the <code>ppp</code> function.</li>
<li>The <code>IntExponential</code> kernel is suitable for modeling processes with exponential decay 
    along one dimension with integrated covariance structures.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">IntExponential</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrated Exponential (IntExponential) kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `IntExponential` class defines a kernel that integrates the Exponential kernel</span>
<span class="sd">    along a specified axis. This kernel is useful for modeling processes with exponential </span>
<span class="sd">    decay along one dimension, starting from a given point.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        axis (int):</span>
<span class="sd">            The axis along which the integration is performed (e.g., 0 for x-axis, 1 for y-axis).</span>
<span class="sd">        start (float):</span>
<span class="sd">            The starting point of the integration along the specified axis.</span>
<span class="sd">        range (float or tf.Variable):</span>
<span class="sd">            The length scale parameter that controls how quickly the covariance decreases with distance.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using an `IntExponential` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import IntExponential</span>

<span class="sd">        # Create an IntExponential kernel integrating along the x-axis starting from 0.0 with a range of 2.0</span>
<span class="sd">        int_exp_kernel = IntExponential(axis=0, start=0.0, range=2.0)</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = int_exp_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;range&#39;: 2.0})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the integrated exponential covariance matrix based on the </span>
<span class="sd">            specified axis, starting point, and range.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for `range` using the `ppp` function.</span>
<span class="sd">        - The `IntExponential` kernel is suitable for modeling processes with exponential decay </span>
<span class="sd">            along one dimension with integrated covariance structures.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nb">range</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>

        <span class="c1"># Include the element of scale corresponding to the axis of</span>
        <span class="c1"># integration as an explicit formal argument.</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">locs1</span><span class="o">=</span><span class="s1">&#39;locs1&#39;</span><span class="p">,</span> <span class="n">locs2</span><span class="o">=</span><span class="s1">&#39;locs2&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs1&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs2&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]</span>
        <span class="n">sdiff</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ed</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ed</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="n">r</span>
        <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sdiff</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">sdiff</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="n">k</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">k</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.IntSquaredExponential" class="doc doc-heading">
            <code>IntSquaredExponential</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Integrated Squared Exponential (IntSquaredExponential) kernel class for Gaussian Processes (GPs).</p>
<p>The <code>IntSquaredExponential</code> class defines a kernel that integrates the Squared Exponential kernel
along a specified axis. This kernel is useful for modeling processes with smooth variations along 
one dimension, starting from a given point.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>axis</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axis along which the integration is performed (e.g., 0 for x-axis, 1 for y-axis).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>start</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The starting point of the integration along the specified axis.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>range</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The length scale parameter that controls how quickly the covariance decreases with distance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using an <code>IntSquaredExponential</code> kernel:</p>
<pre><code>from geostat.kernel import IntSquaredExponential

# Create an IntSquaredExponential kernel integrating along the x-axis starting from 0.0 with a range of 2.0
int_sq_exp_kernel = IntSquaredExponential(axis=0, start=0.0, range=2.0)

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = int_sq_exp_kernel({'locs1': locs1, 'locs2': locs2, 'range': 2.0})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the integrated squared exponential covariance matrix based on the 
    specified axis, starting point, and range.</li>
<li>The <code>vars</code> method returns the parameter dictionary for <code>range</code> using the <code>ppp</code> function.</li>
<li>The <code>IntSquaredExponential</code> kernel is suitable for modeling smooth processes with integrated 
    covariance structures along one dimension.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">IntSquaredExponential</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrated Squared Exponential (IntSquaredExponential) kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `IntSquaredExponential` class defines a kernel that integrates the Squared Exponential kernel</span>
<span class="sd">    along a specified axis. This kernel is useful for modeling processes with smooth variations along </span>
<span class="sd">    one dimension, starting from a given point.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        axis (int):</span>
<span class="sd">            The axis along which the integration is performed (e.g., 0 for x-axis, 1 for y-axis).</span>
<span class="sd">        start (float):</span>
<span class="sd">            The starting point of the integration along the specified axis.</span>
<span class="sd">        range (float or tf.Variable):</span>
<span class="sd">            The length scale parameter that controls how quickly the covariance decreases with distance.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using an `IntSquaredExponential` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import IntSquaredExponential</span>

<span class="sd">        # Create an IntSquaredExponential kernel integrating along the x-axis starting from 0.0 with a range of 2.0</span>
<span class="sd">        int_sq_exp_kernel = IntSquaredExponential(axis=0, start=0.0, range=2.0)</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = int_sq_exp_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;range&#39;: 2.0})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the integrated squared exponential covariance matrix based on the </span>
<span class="sd">            specified axis, starting point, and range.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for `range` using the `ppp` function.</span>
<span class="sd">        - The `IntSquaredExponential` kernel is suitable for modeling smooth processes with integrated </span>
<span class="sd">            covariance structures along one dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nb">range</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>

        <span class="c1"># Include the element of scale corresponding to the axis of</span>
        <span class="c1"># integration as an explicit formal argument.</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">locs1</span><span class="o">=</span><span class="s1">&#39;locs1&#39;</span><span class="p">,</span> <span class="n">locs2</span><span class="o">=</span><span class="s1">&#39;locs2&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs1&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs2&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]</span>
        <span class="n">sdiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">ed</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ed</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sdiff</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)))</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="n">k</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">k</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Kernel" class="doc doc-heading">
            <code>Kernel</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="src.geostat.op.Op">Op</span></code></p>


        <p>Kernel class representing a covariance function for Gaussian Processes (GPs).</p>
<p>The <code>Kernel</code> class defines the structure of a GP's covariance function. It supports operations
such as addition and multiplication with other kernels, enabling the construction of more
complex kernels through combinations. The class also provides methods for computing the
covariance matrix between sets of locations.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>fa</code></td>
            <td>
                  <code>dict or callable</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary or callable representing the functional attributes of the kernel.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>autoinputs</code></td>
            <td>
                  <code>dict</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary specifying the automatic input mappings for the kernel. If 'offset',
'locs1', or 'locs2' keys are not present, they are added with default values.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>Kernel</code> object:</p>
<pre><code>from geostat.kernel import Kernel
import numpy as np

# Construct kernel and call it on locations
locs1 = np.array([[0.0, 0.0], [1.0, 1.0]])
locs2 = np.array([[2.0, 2.0], [3.0, 3.0]])
kernel = Kernel(fa={'alpha': 1.0}, autoinputs={})
covariance_matrix = kernel({'locs1': locs1, 'locs2': locs2})
print(covariance_matrix) # Covariance matrix only has zero entries as no kernel function was given
# tf.Tensor(
# [[0. 0.]
#  [0. 0.]], shape=(2, 2), dtype=float32)
</code></pre>
<p>Combining two kernels using addition and multiplication:</p>
<pre><code>kernel1 = Kernel(fa={'alpha': 1.0}, autoinputs={})
kernel2 = Kernel(fa={'range': 0.5}, autoinputs={})
combined_kernel = kernel1 + kernel2  # Adding kernels
product_kernel = kernel1 * kernel2   # Multiplying kernels
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>__call__</code> method computes the covariance matrix between two sets of locations 
    (<code>locs1</code> and <code>locs2</code>) and ensures the result is correctly broadcasted to the appropriate shape.</li>
<li>The <code>report</code> method provides a summary of the kernel's parameters and their values.</li>
<li>This class serves as a base class for more specialized kernel functions in GP modeling.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Kernel</span><span class="p">(</span><span class="n">Op</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kernel class representing a covariance function for Gaussian Processes (GPs).</span>

<span class="sd">    The `Kernel` class defines the structure of a GP&#39;s covariance function. It supports operations</span>
<span class="sd">    such as addition and multiplication with other kernels, enabling the construction of more</span>
<span class="sd">    complex kernels through combinations. The class also provides methods for computing the</span>
<span class="sd">    covariance matrix between sets of locations.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        fa (dict or callable):</span>
<span class="sd">            A dictionary or callable representing the functional attributes of the kernel.</span>
<span class="sd">        autoinputs (dict):</span>
<span class="sd">            A dictionary specifying the automatic input mappings for the kernel. If &#39;offset&#39;,</span>
<span class="sd">            &#39;locs1&#39;, or &#39;locs2&#39; keys are not present, they are added with default values.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `Kernel` object:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import Kernel</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        # Construct kernel and call it on locations</span>
<span class="sd">        locs1 = np.array([[0.0, 0.0], [1.0, 1.0]])</span>
<span class="sd">        locs2 = np.array([[2.0, 2.0], [3.0, 3.0]])</span>
<span class="sd">        kernel = Kernel(fa={&#39;alpha&#39;: 1.0}, autoinputs={})</span>
<span class="sd">        covariance_matrix = kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2})</span>
<span class="sd">        print(covariance_matrix) # Covariance matrix only has zero entries as no kernel function was given</span>
<span class="sd">        # tf.Tensor(</span>
<span class="sd">        # [[0. 0.]</span>
<span class="sd">        #  [0. 0.]], shape=(2, 2), dtype=float32)</span>
<span class="sd">        ```</span>

<span class="sd">        Combining two kernels using addition and multiplication:</span>

<span class="sd">        ```</span>
<span class="sd">        kernel1 = Kernel(fa={&#39;alpha&#39;: 1.0}, autoinputs={})</span>
<span class="sd">        kernel2 = Kernel(fa={&#39;range&#39;: 0.5}, autoinputs={})</span>
<span class="sd">        combined_kernel = kernel1 + kernel2  # Adding kernels</span>
<span class="sd">        product_kernel = kernel1 * kernel2   # Multiplying kernels</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `__call__` method computes the covariance matrix between two sets of locations </span>
<span class="sd">            (`locs1` and `locs2`) and ensures the result is correctly broadcasted to the appropriate shape.</span>
<span class="sd">        - The `report` method provides a summary of the kernel&#39;s parameters and their values.</span>
<span class="sd">        - This class serves as a base class for more specialized kernel functions in GP modeling.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">autoinputs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;offset&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">autoinputs</span><span class="p">:</span> <span class="n">autoinputs</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;offset&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;locs1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">autoinputs</span><span class="p">:</span> <span class="n">autoinputs</span><span class="p">[</span><span class="s1">&#39;locs1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;locs1&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;locs2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">autoinputs</span><span class="p">:</span> <span class="n">autoinputs</span><span class="p">[</span><span class="s1">&#39;locs2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;locs2&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">autoinputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Stack</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Product</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns covariance for locations.</span>
<span class="sd">        Return values may be unbroadcasted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns covariance for locations.</span>
<span class="sd">        Return values have correct shapes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">C</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs1&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs2&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%4.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">())</span>
        <span class="k">return</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="n">string</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Mix" class="doc doc-heading">
            <code>Mix</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Mix kernel class for combining multiple Gaussian Process (GP) kernels.</p>
<p>The <code>Mix</code> class defines a kernel that allows combining multiple input kernels, either using 
specified weights or by directly mixing the component kernels. This provides a flexible way to 
create complex covariance structures by blending the properties of different kernels.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>inputs</code></td>
            <td>
                  <code>list of Kernel objects</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of kernel objects to be combined.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>weights</code></td>
            <td>
                  <code>matrix</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A matrix specifying how the input kernels should be combined. If not provided, 
the kernels are combined without weighting.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Combining multiple kernels with specified weights:</p>
<pre><code>from geostat.kernel import Mix, SquaredExponential, Noise

# Create individual kernels
kernel1 = SquaredExponential(sill=1.0, range=2.0)
kernel2 = Noise(nugget=0.1)

# Combine kernels using the Mix class
mixed_kernel = Mix(inputs=[kernel1, kernel2], weights=[[0.6, 0.4], [0.4, 0.6]])

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = mixed_kernel({'locs1': locs1, 'locs2': locs2, 'weights': [[0.6, 0.4], [0.4, 0.6]]})
</code></pre>
<p>Using the <code>Mix</code> kernel without weights:</p>
<pre><code>mixed_kernel_no_weights = Mix(inputs=[kernel1, kernel2])
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix by either using the specified weights 
    to combine the input kernels or directly combining them when weights are not provided.</li>
<li>The <code>vars</code> method gathers the parameters from all input kernels, allowing for easy 
    access and manipulation of their coefficients.</li>
<li>The <code>Mix</code> kernel is useful for creating complex, multi-faceted covariance structures 
    by blending different types of kernels, providing enhanced modeling flexibility.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Mix</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mix kernel class for combining multiple Gaussian Process (GP) kernels.</span>

<span class="sd">    The `Mix` class defines a kernel that allows combining multiple input kernels, either using </span>
<span class="sd">    specified weights or by directly mixing the component kernels. This provides a flexible way to </span>
<span class="sd">    create complex covariance structures by blending the properties of different kernels.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        inputs (list of Kernel objects):</span>
<span class="sd">            A list of kernel objects to be combined.</span>
<span class="sd">        weights (matrix, optional):</span>
<span class="sd">            A matrix specifying how the input kernels should be combined. If not provided, </span>
<span class="sd">            the kernels are combined without weighting.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Combining multiple kernels with specified weights:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import Mix, SquaredExponential, Noise</span>

<span class="sd">        # Create individual kernels</span>
<span class="sd">        kernel1 = SquaredExponential(sill=1.0, range=2.0)</span>
<span class="sd">        kernel2 = Noise(nugget=0.1)</span>

<span class="sd">        # Combine kernels using the Mix class</span>
<span class="sd">        mixed_kernel = Mix(inputs=[kernel1, kernel2], weights=[[0.6, 0.4], [0.4, 0.6]])</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = mixed_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;weights&#39;: [[0.6, 0.4], [0.4, 0.6]]})</span>
<span class="sd">        ```</span>

<span class="sd">        Using the `Mix` kernel without weights:</span>

<span class="sd">        ```</span>
<span class="sd">        mixed_kernel_no_weights = Mix(inputs=[kernel1, kernel2])</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix by either using the specified weights </span>
<span class="sd">            to combine the input kernels or directly combining them when weights are not provided.</span>
<span class="sd">        - The `vars` method gathers the parameters from all input kernels, allowing for easy </span>
<span class="sd">            access and manipulation of their coefficients.</span>
<span class="sd">        - The `Mix` kernel is useful for creating complex, multi-faceted covariance structures </span>
<span class="sd">            by blending different types of kernels, providing enhanced modeling flexibility.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ai</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cats1</span><span class="o">=</span><span class="s1">&#39;cats1&#39;</span><span class="p">,</span> <span class="n">cats2</span><span class="o">=</span><span class="s1">&#39;cats2&#39;</span><span class="p">)</span>

        <span class="c1"># Special case if weights is not given.</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fa</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>
            <span class="n">ai</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">gather_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a special version of gather_vars because</span>
<span class="sd">           we want to gather variables from `inputs`</span>
<span class="sd">           even when it&#39;s not in autoinputs&quot;&quot;&quot;</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iput</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
            <span class="n">cache</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">|=</span> <span class="n">iput</span><span class="o">.</span><span class="n">gather_vars</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;weights&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">get_trend_coefs</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;weights&#39;</span> <span class="ow">in</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                    <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [locs, locs, numinputs].</span>
            <span class="n">Aaug1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;cats1&#39;</span><span class="p">])</span> <span class="c1"># [locs, numinputs].</span>
            <span class="n">Aaug2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;cats2&#39;</span><span class="p">])</span> <span class="c1"># [locs, numinputs].</span>
            <span class="n">outer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ac,bc-&gt;abc&#39;</span><span class="p">,</span> <span class="n">Aaug1</span><span class="p">,</span> <span class="n">Aaug2</span><span class="p">)</span> <span class="c1"># [locs, locs, numinputs].</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abc,abc-&gt;ab&#39;</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">outer</span><span class="p">)</span> <span class="c1"># [locs, locs].</span>
            <span class="k">return</span> <span class="n">C</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When weights is not given, exploit the fact that we don&#39;t have</span>
            <span class="c1"># to compute every element in component covariance matrices.</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">catcounts1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;cats1&#39;</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">maxlength</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
            <span class="n">catcounts2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;cats2&#39;</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">maxlength</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
            <span class="n">catindices1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">catcounts1</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">catindices2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">catcounts2</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">catdiffs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">catindices2</span> <span class="o">-</span> <span class="n">catindices1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
            <span class="n">locsegs1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs1&#39;</span><span class="p">],</span> <span class="n">catcounts1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
            <span class="n">locsegs2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs2&#39;</span><span class="p">],</span> <span class="n">catcounts2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

            <span class="c1"># TODO: Check that the below is still correct.</span>
            <span class="n">CC</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Observation noise submatrices.</span>
            <span class="k">for</span> <span class="n">sublocs1</span><span class="p">,</span> <span class="n">sublocs2</span><span class="p">,</span> <span class="n">catdiff</span><span class="p">,</span> <span class="n">iput</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">locsegs1</span><span class="p">,</span> <span class="n">locsegs2</span><span class="p">,</span> <span class="n">catdiffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">catdiff</span><span class="p">,</span>
                    <span class="n">locs1</span> <span class="o">=</span> <span class="n">sublocs1</span><span class="p">,</span>
                    <span class="n">locs2</span> <span class="o">=</span> <span class="n">sublocs2</span><span class="p">)</span>
                <span class="n">cache</span><span class="p">[</span><span class="s1">&#39;per_axis_dist2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PerAxisDist2</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
                <span class="n">cache</span><span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Euclidean</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
                <span class="n">Csub</span> <span class="o">=</span> <span class="n">iput</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
                <span class="n">CC</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Csub</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Noise" class="doc doc-heading">
            <code>Noise</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Noise kernel class for Gaussian Processes (GPs).</p>
<p>The <code>Noise</code> class defines a kernel that models the nugget effect, which represents uncorrelated noise
in the data. It produces a diagonal covariance matrix with the specified <code>nugget</code> value, indicating 
the presence of noise at each location.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>nugget</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The variance (nugget) representing the noise level. This value is added to the diagonal 
of the covariance matrix.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>Noise</code> kernel:</p>
<pre><code>from geostat.kernel import Noise

# Create a Noise kernel with a nugget value of 0.1
noise_kernel = Noise(nugget=0.1)

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = noise_kernel({'locs1': locs1, 'locs2': locs2, 'nugget': 0.1})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes a diagonal covariance matrix where the diagonal elements are equal 
    to <code>nugget</code>, representing noise at each location. Off-diagonal elements are set to 0.</li>
<li>The <code>vars</code> method returns the parameter dictionary for <code>nugget</code> using the <code>ppp</code> function.</li>
<li>The <code>Noise</code> kernel is useful for modeling independent noise in the data, especially when the 
    observations contain measurement error or variability that cannot be explained by the model.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Noise</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Noise kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `Noise` class defines a kernel that models the nugget effect, which represents uncorrelated noise</span>
<span class="sd">    in the data. It produces a diagonal covariance matrix with the specified `nugget` value, indicating </span>
<span class="sd">    the presence of noise at each location.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        nugget (float or tf.Variable):</span>
<span class="sd">            The variance (nugget) representing the noise level. This value is added to the diagonal </span>
<span class="sd">            of the covariance matrix.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `Noise` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import Noise</span>

<span class="sd">        # Create a Noise kernel with a nugget value of 0.1</span>
<span class="sd">        noise_kernel = Noise(nugget=0.1)</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = noise_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;nugget&#39;: 0.1})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes a diagonal covariance matrix where the diagonal elements are equal </span>
<span class="sd">            to `nugget`, representing noise at each location. Off-diagonal elements are set to 0.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for `nugget` using the `ppp` function.</span>
<span class="sd">        - The `Noise` kernel is useful for modeling independent noise in the data, especially when the </span>
<span class="sd">            observations contain measurement error or variability that cannot be explained by the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nugget</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">nugget</span><span class="o">=</span><span class="n">nugget</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">locs1</span><span class="o">=</span><span class="s1">&#39;locs1&#39;</span><span class="p">,</span> <span class="n">locs2</span><span class="o">=</span><span class="s1">&#39;locs2&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;nugget&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>

        <span class="n">indices1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs1&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">indices2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs2&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">indices1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">indices2</span><span class="p">),</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;nugget&#39;</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Product" class="doc doc-heading">
            <code>Product</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Product kernel class for combining multiple Gaussian Process (GP) kernels multiplicatively.</p>
<p>The <code>Product</code> class defines a kernel that combines multiple input kernels by multiplying them together.
This multiplicative combination allows for capturing interactions between the individual kernels, resulting
in a more complex and flexible covariance structure.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>parts</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of kernel objects to be combined multiplicatively.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>Product</code> kernel:</p>
<pre><code>from geostat.kernel import Product, SquaredExponential, Noise

# Create individual kernels
kernel1 = SquaredExponential(sill=1.0, range=2.0)
kernel2 = Noise(nugget=0.1)

# Combine kernels using the Product class
product_kernel = Product(parts=[kernel1, kernel2])

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = product_kernel({'locs1': locs1, 'locs2': locs2})
</code></pre>
<p>Multiplying another kernel with an existing <code>Product</code> kernel:</p>
<pre><code>kernel3 = SquaredExponential(sill=0.5, range=1.0)
combined_product = product_kernel * kernel3
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the product of all covariance matrices generated by the multiplied kernels.</li>
<li>The <code>vars</code> method gathers parameters from all input kernels, making them accessible for optimization.</li>
<li>The <code>Product</code> kernel is useful for building models where the covariance structure results from 
    multiplicative interactions between different kernels, allowing for more complex GP models.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Product kernel class for combining multiple Gaussian Process (GP) kernels multiplicatively.</span>

<span class="sd">    The `Product` class defines a kernel that combines multiple input kernels by multiplying them together.</span>
<span class="sd">    This multiplicative combination allows for capturing interactions between the individual kernels, resulting</span>
<span class="sd">    in a more complex and flexible covariance structure.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        parts (List[Kernel]):</span>
<span class="sd">            A list of kernel objects to be combined multiplicatively.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `Product` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import Product, SquaredExponential, Noise</span>

<span class="sd">        # Create individual kernels</span>
<span class="sd">        kernel1 = SquaredExponential(sill=1.0, range=2.0)</span>
<span class="sd">        kernel2 = Noise(nugget=0.1)</span>

<span class="sd">        # Combine kernels using the Product class</span>
<span class="sd">        product_kernel = Product(parts=[kernel1, kernel2])</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = product_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2})</span>
<span class="sd">        ```</span>

<span class="sd">        Multiplying another kernel with an existing `Product` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        kernel3 = SquaredExponential(sill=0.5, range=1.0)</span>
<span class="sd">        combined_product = product_kernel * kernel3</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the product of all covariance matrices generated by the multiplied kernels.</span>
<span class="sd">        - The `vars` method gathers parameters from all input kernels, making them accessible for optimization.</span>
<span class="sd">        - The `Product` kernel is useful for building models where the covariance structure results from </span>
<span class="sd">            multiplicative interactions between different kernels, allowing for more complex GP models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Kernel</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parts</span> <span class="o">=</span> <span class="n">parts</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({},</span> <span class="nb">dict</span><span class="p">(</span><span class="n">locs1</span><span class="o">=</span><span class="s1">&#39;locs1&#39;</span><span class="p">,</span> <span class="n">locs2</span><span class="o">=</span><span class="s1">&#39;locs2&#39;</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="n">parts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">vars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_prod</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;parts&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.QuadStack" class="doc doc-heading">
            <code>QuadStack</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>QuadStack kernel class for Gaussian Processes (GPs).</p>
<p>The <code>QuadStack</code> class defines a kernel that combines multiple quadratic components to model complex 
covariance structures. It allows for multiple sills and ranges, providing flexibility in capturing 
covariance that varies across different scales.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>range</code></td>
            <td>
                  <code>list or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list or TensorFlow variable representing the length scale parameters that control how 
quickly the covariance decreases with distance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>sill</code></td>
            <td>
                  <code>list or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list or TensorFlow variable representing the variance (sill) values for each quadratic component.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>scale</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional scale parameter that can be used to modify the metric. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>metric</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional metric used for distance calculation. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>QuadStack</code> kernel:</p>
<pre><code>from geostat.kernel import QuadStack

# Create a QuadStack kernel with multiple sills and ranges
quad_stack_kernel = QuadStack(range=[2.0, 3.0], sill=[1.0, 0.5])

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = quad_stack_kernel({'locs1': locs1, 'locs2': locs2, 'sill': [1.0, 0.5], 'range': [2.0, 3.0]})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix using the <code>quadstack</code> function, which applies 
    multiple quadratic functions based on the provided <code>sill</code> and <code>range</code> values for each component.</li>
<li>The <code>vars</code> method returns the parameter dictionary for both <code>sill</code> and <code>range</code> using the <code>ppp_list</code> function.</li>
<li>The <code>QuadStack</code> kernel is useful for modeling processes that exhibit multiple levels of variability 
    or changes in smoothness at different scales with a quadratic structure.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">QuadStack</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    QuadStack kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `QuadStack` class defines a kernel that combines multiple quadratic components to model complex </span>
<span class="sd">    covariance structures. It allows for multiple sills and ranges, providing flexibility in capturing </span>
<span class="sd">    covariance that varies across different scales.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        range (list or tf.Variable):</span>
<span class="sd">            A list or TensorFlow variable representing the length scale parameters that control how </span>
<span class="sd">            quickly the covariance decreases with distance.</span>
<span class="sd">        sill (list or tf.Variable):</span>
<span class="sd">            A list or TensorFlow variable representing the variance (sill) values for each quadratic component.</span>
<span class="sd">        scale (optional):</span>
<span class="sd">            An optional scale parameter that can be used to modify the metric. Default is None.</span>
<span class="sd">        metric (optional):</span>
<span class="sd">            An optional metric used for distance calculation. Default is None.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `QuadStack` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import QuadStack</span>

<span class="sd">        # Create a QuadStack kernel with multiple sills and ranges</span>
<span class="sd">        quad_stack_kernel = QuadStack(range=[2.0, 3.0], sill=[1.0, 0.5])</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = quad_stack_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;sill&#39;: [1.0, 0.5], &#39;range&#39;: [2.0, 3.0]})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix using the `quadstack` function, which applies </span>
<span class="sd">            multiple quadratic functions based on the provided `sill` and `range` values for each component.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for both `sill` and `range` using the `ppp_list` function.</span>
<span class="sd">        - The `QuadStack` kernel is useful for modeling processes that exhibit multiple levels of variability </span>
<span class="sd">            or changes in smoothness at different scales with a quadratic structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sill</span><span class="o">=</span><span class="n">sill</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">autoinputs</span> <span class="o">=</span> <span class="n">scale_to_metric</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d2</span><span class="o">=</span><span class="n">autoinputs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">ppp_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">quadstack</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;d2&#39;</span><span class="p">]),</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Ramp" class="doc doc-heading">
            <code>Ramp</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Ramp kernel class for Gaussian Processes (GPs).</p>
<p>The <code>Ramp</code> class defines a kernel that produces a covariance structure resembling a "ramp" function.
It is characterized by a sill (variance) and a range (length scale) and can optionally use a metric for scaling.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>range</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The length scale parameter that controls how quickly the covariance decreases with distance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>sill</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The variance (sill) of the kernel, representing the maximum covariance value.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>scale</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional scale parameter that can be used to modify the metric. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>metric</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional metric used for distance calculation. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>Ramp</code> kernel:</p>
<pre><code>from geostat.kernel import Ramp

# Create a Ramp kernel with sill=1.0 and range=2.0
ramp_kernel = Ramp(range=2.0, sill=1.0)

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = ramp_kernel({'locs1': locs1, 'locs2': locs2, 'sill': 1.0, 'range': 2.0})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix using the ramp function:
    <span class="arithmatex">\( C(x, x') = \text{sill} \cdot \text{ramp}\left(\frac{\sqrt{d^2}}{\text{range}}\right) \)</span>,
    where <span class="arithmatex">\(d^2\)</span> is the squared distance between <code>locs1</code> and <code>locs2</code>.</li>
<li>The <code>vars</code> method returns the parameter dictionary for both <code>sill</code> and <code>range</code> using the <code>ppp</code> function.</li>
<li>The <code>Ramp</code> kernel can be used in cases where the covariance structure exhibits a linear decay with increasing distance.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Ramp</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ramp kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `Ramp` class defines a kernel that produces a covariance structure resembling a &quot;ramp&quot; function.</span>
<span class="sd">    It is characterized by a sill (variance) and a range (length scale) and can optionally use a metric for scaling.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        range (float or tf.Variable):</span>
<span class="sd">            The length scale parameter that controls how quickly the covariance decreases with distance.</span>
<span class="sd">        sill (float or tf.Variable):</span>
<span class="sd">            The variance (sill) of the kernel, representing the maximum covariance value.</span>
<span class="sd">        scale (optional):</span>
<span class="sd">            An optional scale parameter that can be used to modify the metric. Default is None.</span>
<span class="sd">        metric (optional):</span>
<span class="sd">            An optional metric used for distance calculation. Default is None.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `Ramp` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import Ramp</span>

<span class="sd">        # Create a Ramp kernel with sill=1.0 and range=2.0</span>
<span class="sd">        ramp_kernel = Ramp(range=2.0, sill=1.0)</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = ramp_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;sill&#39;: 1.0, &#39;range&#39;: 2.0})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix using the ramp function:</span>
<span class="sd">            \\( C(x, x&#39;) = \\text{sill} \cdot \\text{ramp}\left(\\frac{\sqrt{d^2}}{\\text{range}}\\right) \\),</span>
<span class="sd">            where \\(d^2\\) is the squared distance between `locs1` and `locs2`.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for both `sill` and `range` using the `ppp` function.</span>
<span class="sd">        - The `Ramp` kernel can be used in cases where the covariance structure exhibits a linear decay with increasing distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sill</span><span class="o">=</span><span class="n">sill</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">autoinputs</span> <span class="o">=</span> <span class="n">scale_to_metric</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d2</span><span class="o">=</span><span class="n">autoinputs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ramp</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;d2&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.RampStack" class="doc doc-heading">
            <code>RampStack</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>RampStack kernel class for Gaussian Processes (GPs).</p>
<p>The <code>RampStack</code> class defines a kernel that extends the standard <code>Ramp</code> kernel by allowing for multiple 
sills and ranges, effectively creating a "stacked" ramp function. This kernel can capture more complex 
covariance structures with multiple levels of decay.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>range</code></td>
            <td>
                  <code>list or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list or TensorFlow variable representing the length scale parameters that control how quickly 
the covariance decreases with distance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>sill</code></td>
            <td>
                  <code>list or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list or TensorFlow variable representing the variance (sill) values for each ramp component.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>scale</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional scale parameter that can be used to modify the metric. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>metric</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional metric used for distance calculation. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>RampStack</code> kernel:</p>
<pre><code>from geostat.kernel import RampStack

# Create a RampStack kernel with multiple sills and ranges
ramp_stack_kernel = RampStack(range=[2.0, 3.0], sill=[1.0, 0.5])

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = ramp_stack_kernel({'locs1': locs1, 'locs2': locs2, 'sill': [1.0, 0.5], 'range': [2.0, 3.0]})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix using the <code>rampstack</code> function, which applies 
    multiple ramp functions based on the provided <code>sill</code> and <code>range</code> values for each component.</li>
<li>The <code>vars</code> method returns the parameter dictionary for both <code>sill</code> and <code>range</code> using the <code>ppp_list</code> function.</li>
<li>The <code>RampStack</code> kernel is useful for modeling complex processes that exhibit multiple levels of variability 
    or changes in smoothness at different scales.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">RampStack</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RampStack kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `RampStack` class defines a kernel that extends the standard `Ramp` kernel by allowing for multiple </span>
<span class="sd">    sills and ranges, effectively creating a &quot;stacked&quot; ramp function. This kernel can capture more complex </span>
<span class="sd">    covariance structures with multiple levels of decay.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        range (list or tf.Variable):</span>
<span class="sd">            A list or TensorFlow variable representing the length scale parameters that control how quickly </span>
<span class="sd">            the covariance decreases with distance.</span>
<span class="sd">        sill (list or tf.Variable):</span>
<span class="sd">            A list or TensorFlow variable representing the variance (sill) values for each ramp component.</span>
<span class="sd">        scale (optional):</span>
<span class="sd">            An optional scale parameter that can be used to modify the metric. Default is None.</span>
<span class="sd">        metric (optional):</span>
<span class="sd">            An optional metric used for distance calculation. Default is None.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `RampStack` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import RampStack</span>

<span class="sd">        # Create a RampStack kernel with multiple sills and ranges</span>
<span class="sd">        ramp_stack_kernel = RampStack(range=[2.0, 3.0], sill=[1.0, 0.5])</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = ramp_stack_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;sill&#39;: [1.0, 0.5], &#39;range&#39;: [2.0, 3.0]})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix using the `rampstack` function, which applies </span>
<span class="sd">            multiple ramp functions based on the provided `sill` and `range` values for each component.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for both `sill` and `range` using the `ppp_list` function.</span>
<span class="sd">        - The `RampStack` kernel is useful for modeling complex processes that exhibit multiple levels of variability </span>
<span class="sd">            or changes in smoothness at different scales.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sill</span><span class="o">=</span><span class="n">sill</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">autoinputs</span> <span class="o">=</span> <span class="n">scale_to_metric</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d2</span><span class="o">=</span><span class="n">autoinputs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">ppp_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">rampstack</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;d2&#39;</span><span class="p">]),</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.SmoothConvex" class="doc doc-heading">
            <code>SmoothConvex</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>SmoothConvex kernel class for Gaussian Processes (GPs).</p>
<p>The <code>SmoothConvex</code> class defines a kernel that produces a smooth and convex covariance structure. 
It allows for multiple sills and ranges, enabling a more complex representation of covariance that 
smoothly transitions across different scales.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>range</code></td>
            <td>
                  <code>list or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list or TensorFlow variable representing the length scale parameters that control how 
quickly the covariance decreases with distance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>sill</code></td>
            <td>
                  <code>list or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list or TensorFlow variable representing the variance (sill) values for each smooth convex component.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>scale</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional scale parameter that can be used to modify the metric. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>metric</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional metric used for distance calculation. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>SmoothConvex</code> kernel:</p>
<pre><code>from geostat.kernel import SmoothConvex

# Create a SmoothConvex kernel with multiple sills and ranges
smooth_convex_kernel = SmoothConvex(range=[2.0, 3.0], sill=[1.0, 0.5])

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = smooth_convex_kernel({'locs1': locs1, 'locs2': locs2, 'sill': [1.0, 0.5], 'range': [2.0, 3.0]})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix using the <code>smooth_convex</code> function, which applies 
    multiple convex functions based on the provided <code>sill</code> and <code>range</code> values for each component.</li>
<li>The <code>vars</code> method returns the parameter dictionary for both <code>sill</code> and <code>range</code> using the <code>ppp_list</code> function.</li>
<li>The <code>SmoothConvex</code> kernel is useful for modeling processes that require smooth transitions and convexity 
    in their covariance structure across different scales.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">SmoothConvex</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SmoothConvex kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `SmoothConvex` class defines a kernel that produces a smooth and convex covariance structure. </span>
<span class="sd">    It allows for multiple sills and ranges, enabling a more complex representation of covariance that </span>
<span class="sd">    smoothly transitions across different scales.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        range (list or tf.Variable):</span>
<span class="sd">            A list or TensorFlow variable representing the length scale parameters that control how </span>
<span class="sd">            quickly the covariance decreases with distance.</span>
<span class="sd">        sill (list or tf.Variable):</span>
<span class="sd">            A list or TensorFlow variable representing the variance (sill) values for each smooth convex component.</span>
<span class="sd">        scale (optional):</span>
<span class="sd">            An optional scale parameter that can be used to modify the metric. Default is None.</span>
<span class="sd">        metric (optional):</span>
<span class="sd">            An optional metric used for distance calculation. Default is None.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `SmoothConvex` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import SmoothConvex</span>

<span class="sd">        # Create a SmoothConvex kernel with multiple sills and ranges</span>
<span class="sd">        smooth_convex_kernel = SmoothConvex(range=[2.0, 3.0], sill=[1.0, 0.5])</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = smooth_convex_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;sill&#39;: [1.0, 0.5], &#39;range&#39;: [2.0, 3.0]})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix using the `smooth_convex` function, which applies </span>
<span class="sd">            multiple convex functions based on the provided `sill` and `range` values for each component.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for both `sill` and `range` using the `ppp_list` function.</span>
<span class="sd">        - The `SmoothConvex` kernel is useful for modeling processes that require smooth transitions and convexity </span>
<span class="sd">            in their covariance structure across different scales.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sill</span><span class="o">=</span><span class="n">sill</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">autoinputs</span> <span class="o">=</span> <span class="n">scale_to_metric</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d2</span><span class="o">=</span><span class="n">autoinputs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">ppp_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">smooth_convex</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;d2&#39;</span><span class="p">]),</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.SquaredExponential" class="doc doc-heading">
            <code>SquaredExponential</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>SquaredExponential kernel class for Gaussian Processes (GPs).</p>
<p>The <code>SquaredExponential</code> class defines a widely used kernel that models smooth and continuous 
covariance structures. It is parameterized by a sill (variance) and a range (length scale) 
and can optionally use a metric for scaling.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>sill</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The variance (sill) of the kernel, representing the maximum covariance value.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>range</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The length scale parameter that controls how quickly the covariance decreases 
with distance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>scale</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional scale parameter that can be used to modify the metric. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>metric</code></td>
            <td>
                  <code>optional</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An optional metric used for distance calculation. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>SquaredExponential</code> kernel:</p>
<pre><code>from geostat.kernel import SquaredExponential

# Create a SquaredExponential kernel with a sill of 1.0 and a range of 2.0
sq_exp_kernel = SquaredExponential(sill=1.0, range=2.0)

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = sq_exp_kernel({'locs1': locs1, 'locs2': locs2, 'sill': 1.0, 'range': 2.0})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix using the squared exponential formula:
    <span class="arithmatex">\( C(x, x') = \text{sill} \cdot \exp\left(-0.5 \frac{d^2}{\text{range}^2}\right) \)</span>,
    where <span class="arithmatex">\(d^2\)</span> is the squared distance between <code>locs1</code> and <code>locs2</code>.</li>
<li>The <code>vars</code> method returns the parameter dictionary for both <code>sill</code> and <code>range</code> using the <code>ppp</code> function.</li>
<li>This kernel is appropriate for modeling smooth, continuous processes with no abrupt changes.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">SquaredExponential</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SquaredExponential kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `SquaredExponential` class defines a widely used kernel that models smooth and continuous </span>
<span class="sd">    covariance structures. It is parameterized by a sill (variance) and a range (length scale) </span>
<span class="sd">    and can optionally use a metric for scaling.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        sill (float or tf.Variable):</span>
<span class="sd">            The variance (sill) of the kernel, representing the maximum covariance value.</span>
<span class="sd">        range (float or tf.Variable):</span>
<span class="sd">            The length scale parameter that controls how quickly the covariance decreases </span>
<span class="sd">            with distance.</span>
<span class="sd">        scale (optional):</span>
<span class="sd">            An optional scale parameter that can be used to modify the metric. Default is None.</span>
<span class="sd">        metric (optional):</span>
<span class="sd">            An optional metric used for distance calculation. Default is None.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `SquaredExponential` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import SquaredExponential</span>

<span class="sd">        # Create a SquaredExponential kernel with a sill of 1.0 and a range of 2.0</span>
<span class="sd">        sq_exp_kernel = SquaredExponential(sill=1.0, range=2.0)</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = sq_exp_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;sill&#39;: 1.0, &#39;range&#39;: 2.0})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix using the squared exponential formula:</span>
<span class="sd">            \\( C(x, x&#39;) = \\text{sill} \cdot \exp\left(-0.5 \\frac{d^2}{\\text{range}^2}\\right) \\),</span>
<span class="sd">            where \\(d^2\\) is the squared distance between `locs1` and `locs2`.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for both `sill` and `range` using the `ppp` function.</span>
<span class="sd">        - This kernel is appropriate for modeling smooth, continuous processes with no abrupt changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sill</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sill</span><span class="o">=</span><span class="n">sill</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">)</span>
        <span class="n">autoinputs</span> <span class="o">=</span> <span class="n">scale_to_metric</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d2</span><span class="o">=</span><span class="n">autoinputs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;d2&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]))</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Stack" class="doc doc-heading">
            <code>Stack</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Stack kernel class for combining multiple Gaussian Process (GP) kernels additively.</p>
<p>The <code>Stack</code> class defines a kernel that combines multiple input kernels by stacking them together.
This additive combination allows for capturing a more complex covariance structure by summing the
contributions from each individual kernel.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>parts</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of kernel objects to be combined additively.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>Stack</code> kernel:</p>
<pre><code>from geostat.kernel import Stack, SquaredExponential, Noise

# Create individual kernels
kernel1 = SquaredExponential(sill=1.0, range=2.0)
kernel2 = Noise(nugget=0.1)

# Combine kernels using the Stack class
stacked_kernel = Stack(parts=[kernel1, kernel2])

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = stacked_kernel({'locs1': locs1, 'locs2': locs2})
</code></pre>
<p>Adding another kernel to an existing <code>Stack</code>:</p>
<pre><code>kernel3 = SquaredExponential(sill=0.5, range=1.0)
combined_stack = stacked_kernel + kernel3
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the sum of all covariance matrices generated by the stacked kernels.</li>
<li>The <code>vars</code> method gathers parameters from all input kernels, making them accessible for optimization.</li>
<li>The <code>Stack</code> kernel is useful for building complex models where multiple covariance structures need to be 
    combined additively, enabling richer and more flexible GP models.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Stack</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stack kernel class for combining multiple Gaussian Process (GP) kernels additively.</span>

<span class="sd">    The `Stack` class defines a kernel that combines multiple input kernels by stacking them together.</span>
<span class="sd">    This additive combination allows for capturing a more complex covariance structure by summing the</span>
<span class="sd">    contributions from each individual kernel.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        parts (List[Kernel]):</span>
<span class="sd">            A list of kernel objects to be combined additively.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `Stack` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import Stack, SquaredExponential, Noise</span>

<span class="sd">        # Create individual kernels</span>
<span class="sd">        kernel1 = SquaredExponential(sill=1.0, range=2.0)</span>
<span class="sd">        kernel2 = Noise(nugget=0.1)</span>

<span class="sd">        # Combine kernels using the Stack class</span>
<span class="sd">        stacked_kernel = Stack(parts=[kernel1, kernel2])</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = stacked_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2})</span>
<span class="sd">        ```</span>

<span class="sd">        Adding another kernel to an existing `Stack`:</span>

<span class="sd">        ```</span>
<span class="sd">        kernel3 = SquaredExponential(sill=0.5, range=1.0)</span>
<span class="sd">        combined_stack = stacked_kernel + kernel3</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the sum of all covariance matrices generated by the stacked kernels.</span>
<span class="sd">        - The `vars` method gathers parameters from all input kernels, making them accessible for optimization.</span>
<span class="sd">        - The `Stack` kernel is useful for building complex models where multiple covariance structures need to be </span>
<span class="sd">            combined additively, enabling richer and more flexible GP models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Kernel</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parts</span> <span class="o">=</span> <span class="n">parts</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({},</span> <span class="nb">dict</span><span class="p">(</span><span class="n">locs1</span><span class="o">=</span><span class="s1">&#39;locs1&#39;</span><span class="p">,</span> <span class="n">locs2</span><span class="o">=</span><span class="s1">&#39;locs2&#39;</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="n">parts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">vars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Stack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;parts&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.TrendPrior" class="doc doc-heading">
            <code>TrendPrior</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>TrendPrior class representing a kernel with a linear trend prior for Gaussian Processes (GPs).</p>
<p>The <code>TrendPrior</code> class defines a kernel that incorporates a linear trend in the covariance structure
using a provided featurizer function. This kernel is particularly useful when the underlying process
is expected to exhibit a trend that can be captured by the specified features.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>featurizer</code></td>
            <td>
                  <code><span title="typing.Callable">Callable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A function that takes input locations and returns a feature matrix. This function defines
the features used in the trend prior.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>alpha</code></td>
            <td>
                  <code>float or <span title="tensorflow.Variable">Variable</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The scaling factor (weight) applied to the trend prior.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Defining a TrendPrior kernel with a custom featurizer:</p>
<pre><code>import tensorflow as tf
import geostat
from geostat import Parameters
from geostat.kernel import TrendPrior

# Define a simple featurizer function
@geostat.featurizer()
def simple_featurizer(x, y):
    return x, 2*x, x**2

# Create parameters.
p = Parameters(alpha=0.5)

# Construct kernel and call it
locs1 = tf.constant([[1.0, 1.0], [2.0, 2.0], [3.0, 3.0]])
locs2 = tf.constant([[1.5, 2.0], [2.5, 3.0], [3.5, 4.0], [4.5, 5.0]])
trend_prior_kernel = TrendPrior(featurizer=simple_featurizer, alpha=p.alpha)
covariance_matrix = trend_prior_kernel({'locs1': locs1, 'locs2': locs2, 'alpha': p.alpha.value})
print(covariance_matrix)
# tf.Tensor(
# [[  4.875      9.375     14.875     21.375   ]
#  [ 12.        25.        42.        63.      ]
#  [ 21.375     46.874996  81.37499  124.875   ]], shape=(3, 4), dtype=float32)
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix using the features generated by the featurizer
    function and scales it by the <code>alpha</code> parameter.</li>
<li>The <code>vars</code> method returns the parameter dictionary for <code>alpha</code> using the <code>ppp</code> function.</li>
<li>The <code>TrendPrior</code> kernel is typically used when the GP model needs to account for linear or 
    polynomial trends in the data.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">TrendPrior</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TrendPrior class representing a kernel with a linear trend prior for Gaussian Processes (GPs).</span>

<span class="sd">    The `TrendPrior` class defines a kernel that incorporates a linear trend in the covariance structure</span>
<span class="sd">    using a provided featurizer function. This kernel is particularly useful when the underlying process</span>
<span class="sd">    is expected to exhibit a trend that can be captured by the specified features.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        featurizer (Callable):</span>
<span class="sd">            A function that takes input locations and returns a feature matrix. This function defines</span>
<span class="sd">            the features used in the trend prior.</span>
<span class="sd">        alpha (float or tf.Variable):</span>
<span class="sd">            The scaling factor (weight) applied to the trend prior.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Defining a TrendPrior kernel with a custom featurizer:</span>

<span class="sd">        ```</span>
<span class="sd">        import tensorflow as tf</span>
<span class="sd">        import geostat</span>
<span class="sd">        from geostat import Parameters</span>
<span class="sd">        from geostat.kernel import TrendPrior</span>

<span class="sd">        # Define a simple featurizer function</span>
<span class="sd">        @geostat.featurizer()</span>
<span class="sd">        def simple_featurizer(x, y):</span>
<span class="sd">            return x, 2*x, x**2</span>

<span class="sd">        # Create parameters.</span>
<span class="sd">        p = Parameters(alpha=0.5)</span>

<span class="sd">        # Construct kernel and call it</span>
<span class="sd">        locs1 = tf.constant([[1.0, 1.0], [2.0, 2.0], [3.0, 3.0]])</span>
<span class="sd">        locs2 = tf.constant([[1.5, 2.0], [2.5, 3.0], [3.5, 4.0], [4.5, 5.0]])</span>
<span class="sd">        trend_prior_kernel = TrendPrior(featurizer=simple_featurizer, alpha=p.alpha)</span>
<span class="sd">        covariance_matrix = trend_prior_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2, &#39;alpha&#39;: p.alpha.value})</span>
<span class="sd">        print(covariance_matrix)</span>
<span class="sd">        # tf.Tensor(</span>
<span class="sd">        # [[  4.875      9.375     14.875     21.375   ]</span>
<span class="sd">        #  [ 12.        25.        42.        63.      ]</span>
<span class="sd">        #  [ 21.375     46.874996  81.37499  124.875   ]], shape=(3, 4), dtype=float32)</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix using the features generated by the featurizer</span>
<span class="sd">            function and scales it by the `alpha` parameter.</span>
<span class="sd">        - The `vars` method returns the parameter dictionary for `alpha` using the `ppp` function.</span>
<span class="sd">        - The `TrendPrior` kernel is typically used when the GP model needs to account for linear or </span>
<span class="sd">            polynomial trends in the data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">featurizer</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">featurizer</span> <span class="o">=</span> <span class="n">featurizer</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">locs1</span><span class="o">=</span><span class="s1">&#39;locs1&#39;</span><span class="p">,</span> <span class="n">locs2</span><span class="o">=</span><span class="s1">&#39;locs2&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ppp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="n">F1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurizer</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs1&#39;</span><span class="p">]),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">F2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurizer</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs2&#39;</span><span class="p">]),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ba,ca-&gt;bc&#39;</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.geostat.kernel.Wiener" class="doc doc-heading">
            <code>Wiener</code>


</h3>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.geostat.kernel.Kernel" href="#src.geostat.kernel.Kernel">Kernel</a></code></p>


        <p>Wiener kernel class for Gaussian Processes (GPs).</p>
<p>The <code>Wiener</code> class defines a kernel that represents a Wiener process (or Brownian motion) in one dimension.
It models the covariance based on the minimum distance along a specified axis of integration, starting 
from a given point.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>axis</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axis along which the Wiener process operates (e.g., 0 for x-axis, 1 for y-axis).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>start</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The starting point of the Wiener process along the specified axis.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <p>Creating and using a <code>Wiener</code> kernel:</p>
<pre><code>from geostat.kernel import Wiener

# Create a Wiener kernel operating along the x-axis starting from 0.0
wiener_kernel = Wiener(axis=0, start=0.0)

locs1 = np.array([[0.0], [1.0], [2.0]])
locs2 = np.array([[0.0], [1.0], [2.0]])
covariance_matrix = wiener_kernel({'locs1': locs1, 'locs2': locs2})
</code></pre>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The <code>call</code> method computes the covariance matrix using the Wiener process formula, which is based 
    on the minimum distance along the specified <code>axis</code> from the <code>start</code> point.</li>
<li>The <code>vars</code> method returns an empty dictionary since the Wiener kernel does not have tunable parameters.</li>
<li>The <code>Wiener</code> kernel is suitable for modeling processes that evolve with time or any other 
    ordered dimension, representing a type of random walk or Brownian motion.</li>
</ul>
</details>
              <details class="quote">
                <summary>Source code in <code>src/geostat/kernel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Wiener</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wiener kernel class for Gaussian Processes (GPs).</span>

<span class="sd">    The `Wiener` class defines a kernel that represents a Wiener process (or Brownian motion) in one dimension.</span>
<span class="sd">    It models the covariance based on the minimum distance along a specified axis of integration, starting </span>
<span class="sd">    from a given point.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        axis (int):</span>
<span class="sd">            The axis along which the Wiener process operates (e.g., 0 for x-axis, 1 for y-axis).</span>
<span class="sd">        start (float):</span>
<span class="sd">            The starting point of the Wiener process along the specified axis.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating and using a `Wiener` kernel:</span>

<span class="sd">        ```</span>
<span class="sd">        from geostat.kernel import Wiener</span>

<span class="sd">        # Create a Wiener kernel operating along the x-axis starting from 0.0</span>
<span class="sd">        wiener_kernel = Wiener(axis=0, start=0.0)</span>

<span class="sd">        locs1 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        locs2 = np.array([[0.0], [1.0], [2.0]])</span>
<span class="sd">        covariance_matrix = wiener_kernel({&#39;locs1&#39;: locs1, &#39;locs2&#39;: locs2})</span>
<span class="sd">        ```</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `call` method computes the covariance matrix using the Wiener process formula, which is based </span>
<span class="sd">            on the minimum distance along the specified `axis` from the `start` point.</span>
<span class="sd">        - The `vars` method returns an empty dictionary since the Wiener kernel does not have tunable parameters.</span>
<span class="sd">        - The `Wiener` kernel is suitable for modeling processes that evolve with time or any other </span>
<span class="sd">            ordered dimension, representing a type of random walk or Brownian motion.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>

        <span class="c1"># Include the element of scale corresponding to the axis of</span>
        <span class="c1"># integration as an explicit formal argument.</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">locs1</span><span class="o">=</span><span class="s1">&#39;locs1&#39;</span><span class="p">,</span> <span class="n">locs2</span><span class="o">=</span><span class="s1">&#39;locs2&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs1&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;locs2&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ed</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ed</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>




  </div>

    </div>

</div><!-- ---

::: src.geostat.krige
    options:
        show_root_heading: True
        show_source: True

---

::: src.geostat.mean
    options:
        show_root_heading: True
        show_source: True

---

::: src.geostat.mesh
    options:
        show_root_heading: True
        show_source: True

---

::: src.geostat.metric
    options:
        show_root_heading: True
        show_source: True

---

::: src.geostat.model
    options:
        show_root_heading: True
        show_source: True
        filters:
          - "!Warp"
          - "!gp_covariance2"
          - "!interpolate_1d_tf"
          - "!mvn_log_pdf"

---

::: src.geostat.op
    options:
        show_root_heading: True
        show_source: True

---

::: src.geostat.param
    options:
        show_root_heading: True
        show_source: True -->












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.525ec568.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>